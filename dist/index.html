<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Annotator Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fafafa;
        }
        .section h2 {
            color: #555;
            margin-top: 0;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, textarea, select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        textarea {
            height: 100px;
            resize: vertical;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .results {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .feature-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .feature-card {
            background: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .feature-card h3 {
            margin-top: 0;
            color: #007bff;
        }
        .demo-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .demo-controls button {
            flex: 1;
            min-width: 120px;
        }
        
        /* Playground Styles */
        .playground-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-group label {
            margin: 0;
            font-weight: bold;
            white-space: nowrap;
        }
        #exampleSelect {
            min-width: 200px;
        }
        .run-button {
            background: linear-gradient(135deg, #4caf50, #45a049);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        .run-button:hover {
            background: linear-gradient(135deg, #45a049, #388e3c);
            transform: translateY(-1px);
        }
        .run-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .reset-button {
            background: linear-gradient(135deg, #ff9800, #f57c00);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .reset-button:hover {
            background: linear-gradient(135deg, #f57c00, #ef6c00);
        }
        
        .playground-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .editor-section, .results-section {
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            background: white;
        }
        
        .editor-header, .results-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .editor-header h3, .results-header h3 {
            margin: 0;
            font-size: 16px;
        }
        .editor-info {
            font-size: 12px;
            opacity: 0.9;
        }
        
        .code-editor {
            height: 400px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            border: none;
            resize: none;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
            overflow: auto;
            line-height: 1.5;
        }
        
        .results-content {
            height: 400px;
            overflow: auto;
            padding: 20px;
            background: #fafafa;
        }
        
        .placeholder {
            text-align: center;
            color: #666;
            padding: 60px 20px;
        }
        .placeholder p {
            margin: 10px 0;
        }
        
        .status-indicator {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 12px;
            background: rgba(255,255,255,0.2);
        }
        .status-indicator.executing {
            background: #ff9800;
            color: white;
        }
        .status-indicator.success {
            background: #4caf50;
            color: white;
        }
        .status-indicator.error {
            background: #f44336;
            color: white;
        }
        
        .execution-result {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .execution-success {
            border: 2px solid #4caf50;
            border-radius: 8px;
            padding: 15px;
            background: #e8f5e8;
        }
        .execution-error {
            border: 2px solid #f44336;
            border-radius: 8px;
            padding: 15px;
            background: #ffebee;
        }
        
        .execution-stats {
            display: flex;
            gap: 15px;
            margin: 10px 0;
            font-size: 12px;
            color: #666;
        }
        
        .page-result {
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
        }
        .page-result h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .match-summary {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            font-size: 12px;
            color: #666;
        }
        
        .matches-list {
            max-height: 200px;
            overflow-y: auto;
        }
        .match-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-size: 12px;
        }
        .match-text {
            font-weight: bold;
            color: #333;
            flex: 1;
        }
        .similarity {
            color: #4caf50;
            font-weight: bold;
        }
        .annotation-type {
            background: #e3f2fd;
            color: #1976d2;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
        }
        
        @media (max-width: 768px) {
            .playground-container {
                grid-template-columns: 1fr;
            }
            .playground-controls {
                flex-direction: column;
                align-items: stretch;
            }
            .control-group {
                justify-content: space-between;
            }
        }
        pre {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            border: 1px solid #e9ecef;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Document Annotator WASM Demo</h1>
        <div style="text-align: center; margin-top: 20px;">
            <a href="docs.html" style="display: inline-block; background: rgba(255,255,255,0.2); color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; margin: 0 10px;">üìö Documentation</a>
            <a href="https://github.com/your-repo/closest-match" style="display: inline-block; background: rgba(255,255,255,0.2); color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; margin: 0 10px;">üì¶ GitHub</a>
        </div>
        
        <div class="section">
            <h2>üìä System Status</h2>
            <div id="systemStatus" class="status info">Loading system...</div>
            <button onclick="initializeSystem()" id="initBtn">Initialize System</button>
        </div>

        <div class="section">
            <h2>üöÄ Feature Overview</h2>
            <div class="feature-list">
                <div class="feature-card">
                    <h3>üîß WASM Core</h3>
                    <p>High-performance string matching algorithms compiled to WebAssembly for fast text processing</p>
                </div>
                <div class="feature-card">
                    <h3>üìù PDF Annotation</h3>
                    <p>Create rectangle, highlight, underline, and strikethrough annotations with custom colors</p>
                </div>
                <div class="feature-card">
                    <h3>üíæ Smart Caching</h3>
                    <p>IndexedDB-based caching system for processed hOCR data and match results</p>
                </div>
                <div class="feature-card">
                    <h3>üé® Rich Text Support</h3>
                    <p>Parse HTML and RTF formatted search queries with automatic format detection</p>
                </div>
                <div class="feature-card">
                    <h3>‚ö° Parallel Processing</h3>
                    <p>Web Workers for concurrent document processing with intelligent load balancing</p>
                </div>
                <div class="feature-card">
                    <h3>üì¶ Batch Optimization</h3>
                    <p>Advanced batch processing with adaptive optimization and performance monitoring</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üß™ API Testing</h2>
            <div class="demo-controls">
                <button onclick="testWasmModule()">Test WASM Module</button>
                <button onclick="testCacheSystem()">Test Cache System</button>
                <button onclick="testRichTextParser()">Test Rich Text Parser</button>
                <button onclick="testWorkerManager()">Test Worker Manager</button>
                <button onclick="testBatchProcessor()">Test Batch Processor</button>
                <button onclick="testCitationGenerator()">Test Citation Generator</button>
            </div>
            <div id="testResults" class="results" style="display: none;">
                <h3>Test Results:</h3>
                <pre id="testOutput"></pre>
            </div>
        </div>

        <div class="section">
            <h2>üìà Performance Metrics</h2>
            <div class="demo-controls">
                <button onclick="getCacheStats()">Cache Statistics</button>
                <button onclick="getWorkerStats()">Worker Statistics</button>
                <button onclick="getBatchStats()">Batch Statistics</button>
                <button onclick="getOptimizationRecommendations()">Optimization Tips</button>
            </div>
            <div id="metricsResults" class="results" style="display: none;">
                <h3>Metrics:</h3>
                <pre id="metricsOutput"></pre>
            </div>
        </div>

        <div class="section">
            <h2>üß™ Interactive Code Playground</h2>
            <p>Test the Document Annotator with real Firebase URLs! Copy examples from the documentation, modify them, and see live results.</p>
            
            <div class="playground-controls">
                <div class="control-group">
                    <label for="exampleSelect">Select Example:</label>
                    <select id="exampleSelect">
                        <option value="basic">Basic Firebase URL Example</option>
                        <option value="formattedText">Formatted Text Highlighting</option>
                        <option value="multi-query">Multi-Query Processing</option>
                        <option value="legal">Legal Document Search</option>
                        <option value="medical">Medical Report Analysis</option>
                        <option value="citation">Citation Generation</option>
                        <option value="custom">Custom Firebase URLs</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <button id="runCode" class="run-button">‚ñ∂Ô∏è Execute Code</button>
                    <button id="resetCode" class="reset-button">üîÑ Reset</button>
                    <button id="copyResult" class="copy-button" style="display: none;">üìã Copy Result</button>
                </div>
            </div>

            <div class="playground-container">
                <div class="editor-section">
                    <div class="editor-header">
                        <h3>JavaScript Code Editor</h3>
                        <span class="editor-info">üí° Modify search queries, URLs, and options</span>
                    </div>
                    <div id="codeEditor" class="code-editor"></div>
                </div>
                
                <div class="results-section">
                    <div class="results-header">
                        <h3>Execution Results</h3>
                        <div id="executionStatus" class="status-indicator">Ready to execute</div>
                    </div>
                    <div id="resultsOutput" class="results-content">
                        <div class="placeholder">
                            <p>üöÄ Click "Execute Code" to see results</p>
                            <p>Your code will run against real Firebase URLs with live WASM processing</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üí° Simple Examples</h2>
            <div class="form-group">
                <label>Rich Text Search Query:</label>
                <textarea id="richTextQuery" placeholder='Try: <strong style="color: red;">Important Text</strong> or {\rtf1\ansi\deff0 \b Bold RTF}'></textarea>
            </div>
            <div class="form-group">
                <label>Mock hOCR Content:</label>
                <textarea id="hocrContent" placeholder="Enter hOCR content to test against...">
&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;
&lt;div class='ocr_page'&gt;
&lt;p class='ocr_par'&gt;
&lt;span class='ocr_line' title='bbox 100 100 400 130'&gt;This is important sample text&lt;/span&gt;
&lt;span class='ocr_line' title='bbox 100 140 450 170'&gt;with some additional content here&lt;/span&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;
                </textarea>
            </div>
            <div class="demo-controls">
                <button onclick="parseRichText()">Parse Rich Text</button>
                <button onclick="mockAnnotation()">Mock Annotation Process</button>
            </div>
            <div id="exampleResults" class="results" style="display: none;">
                <h3>Example Results:</h3>
                <pre id="exampleOutput"></pre>
            </div>
        </div>
    </div>

    <!-- Load PDF-lib for PDF manipulation -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    
    <script type="module">
        // Import WASM module
        import init, * as wasm from './document_annotator.js';
        
        let documentAnnotator = null;
        let wasmInitialized = false;
        let wasmFunctions = {};
        
        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('systemStatus');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        function showResults(elementId, content) {
            const resultsEl = document.getElementById(elementId);
            const outputEl = document.getElementById(elementId.replace('Results', 'Output'));
            outputEl.textContent = JSON.stringify(content, null, 2);
            resultsEl.style.display = 'block';
        }

        // Real WASM-based DocumentAnnotator implementation
        class DocumentAnnotator {
            constructor(enableCaching = true, enableWorkers = false, enableBatchOptimization = true) {
                this.enableCaching = enableCaching;
                this.enableWorkers = enableWorkers;
                this.enableBatchOptimization = enableBatchOptimization;
            }
            
            async initialize() {
                if (!wasmInitialized) {
                    try {
                        // Initialize WASM module
                        await init();
                        
                        // Store functions globally
                        wasmFunctions = {
                            log_version_info: wasm.log_version_info,
                            get_version: wasm.get_version,
                            get_package_name: wasm.get_package_name,
                            get_version_info: wasm.get_version_info,
                            find_closest_match: wasm.find_closest_match,
                            extract_bounding_box: wasm.extract_bounding_box,
                            extract_bounding_box_from_hocr: wasm.extract_bounding_box_from_hocr,
                            calculate_coordinate_transform: wasm.calculate_coordinate_transform,
                            transform_coordinates: wasm.transform_coordinates,
                            create_custom_annotation_style: wasm.create_custom_annotation_style,
                            parse_color: wasm.parse_color
                        };
                        
                        wasmInitialized = true;
                        
                        // Log version info
                        wasm.log_version_info();
                        
                        return true;
                    } catch (error) {
                        console.error('WASM initialization failed:', error);
                        return false;
                    }
                }
                return true;
            }
            
            async testWasm() {
                const initialized = await this.initialize();
                if (!initialized) {
                    return false;
                }
                
                try {
                    const result = wasmFunctions.find_closest_match(
                        "[[PARAGRAPH]] [[LINE 100 200 500 250]] voltage regulator circuit",
                        "voltage regulator"
                    );
                    
                    return result && result.similarity > 0.8;
                } catch (error) {
                    console.error('WASM test failed:', error);
                    return false;
                }
            }
            
            // Mock implementations for compatibility
            async clearCache() {
                return { cleared: true, message: 'Cache cleared (WASM implementation)' };
            }
            
            async getCacheStats() {
                return {
                    version: wasmFunctions.get_version?.() || 'unknown',
                    features: ['word-level-extraction', 'fuzzy-matching', 'enhanced-coordinate-transformation'],
                    wasmLoaded: wasmInitialized
                };
            }
            
            parseRichTextQueries(queries) {
                return queries.map(query => ({
                    original: query,
                    cleaned: query.replace(/<[^>]*>/g, '').trim(),
                    format: query.includes('<') ? 'html' : 'plain'
                }));
            }
            
            parseFormattedText(formattedText) {
                if (!formattedText || !formattedText.includes('background-color')) {
                    return [];
                }
                
                console.log('üé® Parsing formatted text:', formattedText);
                
                // First, normalize escaped quotes to regular quotes
                const normalizedText = formattedText.replace(/\\"/g, '"');
                console.log('üîß Normalized text:', normalizedText);
                
                const highlights = [];
                // Enhanced regex to handle any HTML tag with background-color styling
                // Matches <tag style="...background-color: rgb(r,g,b)...">content</tag>
                // Uses dotall flag to match across newlines and handles any content within tags
                const regex = /<(\w+)[^>]*style="[^"]*background-color:\s*rgb\(([^)]+)\);?[^"]*"[^>]*>(.*?)<\/\1>/gs;
                let match;
                
                // Reset regex lastIndex to ensure we start from the beginning
                regex.lastIndex = 0;
                
                while ((match = regex.exec(normalizedText)) !== null) {
                    const [fullMatch, tagName, rgbValues, text] = match;
                    console.log(`üéØ Found highlight match: tag="${tagName}", rgb="${rgbValues}", text="${text}"`);
                    
                    const [r, g, b] = rgbValues.split(',').map(v => parseInt(v.trim()));
                    
                    // Clean up the text (remove HTML tags and normalize whitespace)
                    const cleanText = text.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();
                    
                    if (cleanText) {
                        highlights.push({
                            text: cleanText,
                            color: { r, g, b },
                            hexColor: `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`
                        });
                        
                        console.log(`‚úÖ Added highlight: "${cleanText}" with color rgb(${r}, ${g}, ${b}) in <${tagName}> tag`);
                    }
                }
                
                console.log('üé® Parsed formatted text highlights:', highlights);
                return highlights;
            }
            
            async extractWordCoordinatesFromHocr(hocrContent, searchText, boundingBox) {
                if (!hocrContent || !searchText) {
                    console.warn('Missing hOCR content or search text for word extraction');
                    return [];
                }
                
                console.log('üîç Extracting word coordinates for:', searchText);
                console.log('üì¶ Within bounding box:', boundingBox);
                console.log('üìÑ hOCR content length:', hocrContent.length);
                
                // First, extract ALL words from hOCR with coordinates
                const allWords = this.extractAllWordsFromHocr(hocrContent);
                console.log(`üìÑ Total words in hOCR: ${allWords.length}`);
                
                // Filter words to only those within the bounding box (with padding)
                const wordsInArea = this.filterWordsWithinBoundingBox(allWords, boundingBox);
                console.log(`üì¶ Words within bounding box: ${wordsInArea.length}`);
                console.log('üìù Words in area:', wordsInArea.map(w => w.text));
                
                return wordsInArea;
            }
            
            // Extract ALL words from hOCR content with their coordinates
            extractAllWordsFromHocr(hocrContent) {
                const words = [];
                
                // Try multiple regex patterns to handle different hOCR formats with nested HTML tags
                const regexPatterns = [
                    // Pattern 1: ocrx_word with strict quotes - captures content with nested tags
                    /<span[^>]*class=['"]ocrx_word['"][^>]*title=['"]([^'"]*bbox\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+))[^'"]*['"][^>]*>(.*?)<\/span>/gs,
                    // Pattern 2: ocrx_word with flexible quotes and spacing - captures content with nested tags
                    /<span[^>]*class[^>]*ocrx_word[^>]*title[^>]*bbox\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)[^>]*>(.*?)<\/span>/gs,
                    // Pattern 3: just 'word' class - captures content with nested tags
                    /<span[^>]*class[^>]*word[^>]*title[^>]*bbox\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)[^>]*>(.*?)<\/span>/gs,
                    // Pattern 4: Very flexible - any span with bbox - captures content with nested tags
                    /<span[^>]*title[^>]*bbox\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)[^>]*>(.*?)<\/span>/gs
                ];
                
                let patternUsed = -1;
                let wordSpanRegex = null;
                
                // Try each regex pattern until we find one that works
                for (let i = 0; i < regexPatterns.length; i++) {
                    const testRegex = new RegExp(regexPatterns[i].source, regexPatterns[i].flags);
                    const testMatch = testRegex.exec(hocrContent);
                    if (testMatch) {
                        console.log(`‚úÖ Pattern ${i + 1} found matches! Using this pattern.`);
                        patternUsed = i;
                        wordSpanRegex = new RegExp(regexPatterns[i].source, regexPatterns[i].flags);
                        break;
                    } else {
                        console.log(`‚ùå Pattern ${i + 1} found no matches.`);
                    }
                }
                
                if (patternUsed === -1) {
                    console.warn('‚ùå No regex patterns matched any word spans in hOCR');
                    return [];
                }
                
                // Extract all words using the working pattern
                let match;
                while ((match = wordSpanRegex.exec(hocrContent)) !== null) {
                    let x1, y1, x2, y2, wordText;
                    
                    if (patternUsed === 0) { // Pattern 1 has extra capture group for full title
                        [, , x1, y1, x2, y2, wordText] = match;
                    } else {
                        [, x1, y1, x2, y2, wordText] = match;
                    }
                    
                    // Clean the word text by removing any HTML tags
                    const cleanText = wordText.replace(/<[^>]*>/g, '').trim();
                    
                    if (cleanText && x1 && y1 && x2 && y2) {
                        const wordBox = {
                            x1: parseInt(x1),
                            y1: parseInt(y1), 
                            x2: parseInt(x2),
                            y2: parseInt(y2),
                            text: cleanText,
                            center: {
                                x: (parseInt(x1) + parseInt(x2)) / 2,
                                y: (parseInt(y1) + parseInt(y2)) / 2
                            }
                        };
                        words.push(wordBox);
                    }
                }
                
                console.log(`üìÑ Extracted ${words.length} words from hOCR using Pattern ${patternUsed + 1}`);
                return words;
            }
            
            // Filter words to only those within the bounding box (with padding)
            filterWordsWithinBoundingBox(allWords, boundingBox, tolerance = 50) {
                const [bboxX1, bboxY1, bboxX2, bboxY2] = boundingBox;
                const wordsInArea = [];
                
                console.log(`üîç Filtering words within bbox [${bboxX1}, ${bboxY1}, ${bboxX2}, ${bboxY2}] with tolerance ${tolerance}`);
                
                for (const word of allWords) {
                    // Check for overlap between word box and bounding box (with tolerance)
                    const wordOverlaps = !(word.x2 < bboxX1 - tolerance || 
                                          word.x1 > bboxX2 + tolerance ||
                                          word.y2 < bboxY1 - tolerance || 
                                          word.y1 > bboxY2 + tolerance);
                    
                    if (wordOverlaps) {
                        wordsInArea.push(word);
                        console.log(`‚úÖ Word "${word.text}" at [${word.x1}, ${word.y1}, ${word.x2}, ${word.y2}] is within area`);
                    }
                }
                
                console.log(`üì¶ Found ${wordsInArea.length} words within bounding box area`);
                return wordsInArea;
            }
            
            // Match highlight text sections to specific word coordinates within the area
            matchHighlightTextToWords(wordsInArea, highlightSections) {
                const highlightCoordinates = [];
                
                console.log('üéØ Matching highlight sections to words:', highlightSections.map(h => h.text));
                console.log('üìù Available words:', wordsInArea.map(w => w.text));
                
                for (const highlight of highlightSections) {
                    const searchWords = highlight.text.toLowerCase().split(/\s+/).filter(w => w.length > 0);
                    console.log(`üîç Looking for highlight "${highlight.text}" (words: ${searchWords.join(', ')})`);
                    
                    const matchedWords = this.findSequentialWordsInArea(wordsInArea, searchWords);
                    
                    if (matchedWords.length > 0) {
                        // Group matched words into lines and create quads for multi-line highlights
                        const quads = this.createQuadsFromWords(matchedWords);
                        
                        // Calculate overall bounding box for all matched words (for the Rect property)
                        const x1 = Math.min(...matchedWords.map(w => w.x1));
                        const y1 = Math.min(...matchedWords.map(w => w.y1));
                        const x2 = Math.max(...matchedWords.map(w => w.x2));
                        const y2 = Math.max(...matchedWords.map(w => w.y2));
                        
                        highlightCoordinates.push({
                            text: highlight.text,
                            color: highlight.color,
                            hexColor: highlight.hexColor,
                            boundingBox: [x1, y1, x2, y2], // Overall bounding box for Rect
                            quads: quads, // Array of quads for multi-line highlighting
                            words: matchedWords,
                            wordCount: matchedWords.length
                        });
                        
                        console.log(`‚úÖ Matched "${highlight.text}" to ${matchedWords.length} words in ${quads.length} quads`);
                        console.log(`üìù Matched words: ${matchedWords.map(w => w.text).join(' ')}`);
                        console.log(`üìê Quads:`, quads.map((q, i) => `Quad ${i+1}: [${q.x1}, ${q.y1}, ${q.x2}, ${q.y2}] (${q.words.map(w => w.text).join(' ')})`));
                    } else {
                        console.warn(`‚ö†Ô∏è Could not find words for highlight: "${highlight.text}"`);
                    }
                }
                
                console.log(`üé® Created ${highlightCoordinates.length} highlight coordinate sets`);
                return highlightCoordinates;
            }
            
            // Group words into quads based on their line positions for multi-line highlights
            createQuadsFromWords(words) {
                if (!words || words.length === 0) return [];
                
                console.log(`üìè Creating quads from ${words.length} words`);
                
                // Group words by line (using Y-coordinate proximity)
                const lineGroups = [];
                const lineToleranceY = 10; // Words within 10px Y difference are considered same line
                
                for (const word of words) {
                    let addedToLine = false;
                    
                    // Try to add to existing line group
                    for (const lineGroup of lineGroups) {
                        const avgY = lineGroup.reduce((sum, w) => sum + w.center.y, 0) / lineGroup.length;
                        if (Math.abs(word.center.y - avgY) <= lineToleranceY) {
                            lineGroup.push(word);
                            addedToLine = true;
                            break;
                        }
                    }
                    
                    // Create new line group if not added to existing one
                    if (!addedToLine) {
                        lineGroups.push([word]);
                    }
                }
                
                console.log(`üìè Grouped words into ${lineGroups.length} lines`);
                
                // Sort line groups by Y position (top to bottom)
                lineGroups.sort((a, b) => {
                    const avgYA = a.reduce((sum, w) => sum + w.center.y, 0) / a.length;
                    const avgYB = b.reduce((sum, w) => sum + w.center.y, 0) / b.length;
                    return avgYA - avgYB;
                });
                
                // Create quads from each line group
                const quads = [];
                for (let i = 0; i < lineGroups.length; i++) {
                    const lineWords = lineGroups[i];
                    
                    // Sort words in this line by X position (left to right)
                    lineWords.sort((a, b) => a.x1 - b.x1);
                    
                    // Create bounding box for this line
                    const x1 = Math.min(...lineWords.map(w => w.x1));
                    const y1 = Math.min(...lineWords.map(w => w.y1));
                    const x2 = Math.max(...lineWords.map(w => w.x2));
                    const y2 = Math.max(...lineWords.map(w => w.y2));
                    
                    quads.push({
                        x1, y1, x2, y2,
                        words: lineWords,
                        lineIndex: i,
                        text: lineWords.map(w => w.text).join(' ')
                    });
                    
                    console.log(`üìê Quad ${i+1}: [${x1}, ${y1}, ${x2}, ${y2}] for "${lineWords.map(w => w.text).join(' ')}"`);
                }
                
                return quads;
            }
            
            // Find sequential words in area that match the search terms
            findSequentialWordsInArea(wordsInArea, searchWords) {
                if (!wordsInArea.length || !searchWords.length) return [];
                
                // Sort words by position (top to bottom, left to right)
                const sortedWords = wordsInArea.slice().sort((a, b) => {
                    const yDiff = a.y1 - b.y1;
                    return Math.abs(yDiff) < 10 ? a.x1 - b.x1 : yDiff; // Same line if Y difference < 10px
                });
                
                console.log(`üîç Searching ${searchWords.length} words in ${sortedWords.length} sorted words`);
                console.log(`üéØ Search words: ${searchWords.join(', ')}`);
                console.log(`üìÑ Available words: ${sortedWords.map(w => w.text).join(' ')}`);
                
                // Use sliding window to find the best match
                let bestMatch = [];
                let bestScore = 0;
                
                for (let startIdx = 0; startIdx <= sortedWords.length - searchWords.length; startIdx++) {
                    const candidateWords = [];
                    let searchIdx = 0;
                    
                    for (let wordIdx = startIdx; wordIdx < sortedWords.length && searchIdx < searchWords.length; wordIdx++) {
                        const word = sortedWords[wordIdx];
                        const searchWord = searchWords[searchIdx];
                        
                        if (this.wordsMatch(word.text, searchWord)) {
                            candidateWords.push(word);
                            searchIdx++;
                            console.log(`‚úÖ Match: "${word.text}" matches search "${searchWord}"`);
                        } else if (candidateWords.length === 0) {
                            // No progress yet, can skip this word
                            continue;
                        } else {
                            // We were building a sequence but hit a non-match
                            // For partial matches, we might want to be more flexible
                            const similarity = this.calculateWordSimilarity(word.text, searchWord);
                            if (similarity > 0.7) {
                                candidateWords.push(word);
                                searchIdx++;
                                console.log(`üîÑ Fuzzy match: "${word.text}" ~= search "${searchWord}" (${similarity.toFixed(2)})`);
                            } else {
                                break; // End this sequence
                            }
                        }
                    }
                    
                    // Score this match (prefer exact matches and complete sequences)
                    const score = (searchIdx / searchWords.length) * candidateWords.length;
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = candidateWords;
                        console.log(`üèÜ New best match with score ${score.toFixed(2)}: ${candidateWords.map(w => w.text).join(' ')}`);
                    }
                }
                
                console.log(`üéØ Final best match: ${bestMatch.map(w => w.text).join(' ')} (score: ${bestScore.toFixed(2)})`);
                return bestMatch;
            }
            
            // Check if two words match (with fuzzy matching)
            wordsMatch(word1, word2) {
                const w1 = word1.toLowerCase().replace(/[^\w]/g, '');
                const w2 = word2.toLowerCase().replace(/[^\w]/g, '');
                
                // Exact match
                if (w1 === w2) return true;
                
                // Partial match (one contains the other)
                if (w1.includes(w2) || w2.includes(w1)) return true;
                
                // For very short words, require exact match
                if (w1.length <= 2 || w2.length <= 2) return false;
                
                // Fuzzy similarity for longer words
                return this.calculateWordSimilarity(w1, w2) > 0.8;
            }
            
            // Calculate similarity between two words
            calculateWordSimilarity(word1, word2) {
                const len1 = word1.length;
                const len2 = word2.length;
                const maxLen = Math.max(len1, len2);
                
                if (maxLen === 0) return 1.0;
                
                // Simple character overlap ratio
                let matches = 0;
                const minLen = Math.min(len1, len2);
                
                for (let i = 0; i < minLen; i++) {
                    if (word1[i] === word2[i]) matches++;
                }
                
                return matches / maxLen;
            }
            
            createTextHighlightQuads(words, searchText) {
                if (!words.length || !searchText) {
                    return [];
                }
                
                console.log('üî§ Creating highlight quads for:', searchText);
                console.log('üîç Available words:', words.map(w => `"${w.text}" at [${w.x1},${w.y1}]`));
                
                // Find words that match the search text (case insensitive, partial matching)
                const searchWords = searchText.toLowerCase().split(/\s+/);
                console.log('üéØ Looking for search words:', searchWords);
                const matchingWords = [];
                
                // Flexible word matching - find individual words that match search terms
                for (const searchWord of searchWords) {
                    const foundWords = words.filter(word => {
                        // Skip empty or very short words
                        if (!word.text || word.text.trim().length < 2) return false;
                        
                        const wordLower = word.text.toLowerCase();
                        const searchLower = searchWord.toLowerCase();
                        
                        // Prefer exact matches first, then partial matches
                        return wordLower === searchLower || 
                               (wordLower.includes(searchLower) && searchLower.length >= 3) ||
                               (searchLower.includes(wordLower) && wordLower.length >= 3);
                    });
                    
                    if (foundWords.length > 0) {
                        console.log(`üéØ Found matches for "${searchWord}":`, foundWords.map(w => `"${w.text}"`));
                        
                        // Prefer exact matches, then longer words
                        const bestMatch = foundWords.sort((a, b) => {
                            const aExact = a.text.toLowerCase() === searchWord.toLowerCase();
                            const bExact = b.text.toLowerCase() === searchWord.toLowerCase();
                            if (aExact && !bExact) return -1;
                            if (!aExact && bExact) return 1;
                            return b.text.length - a.text.length; // Prefer longer words
                        })[0];
                        
                        matchingWords.push(bestMatch);
                        console.log(`‚úÖ Selected best match for "${searchWord}": "${bestMatch.text}"`);
                    } else {
                        console.warn(`‚ö†Ô∏è No match found for "${searchWord}"`);
                    }
                }
                
                if (matchingWords.length === 0) {
                    console.warn('‚ö†Ô∏è No matching words found for:', searchText);
                    return [];
                }
                
                console.log('‚úÖ Found matching words:', matchingWords.map(w => w.text));
                
                // Group words by line (same y-coordinate within tolerance)
                const lines = [];
                const lineToleranceY = 5;
                
                matchingWords.forEach(word => {
                    let addedToLine = false;
                    
                    for (const line of lines) {
                        if (Math.abs(line[0].y1 - word.y1) <= lineToleranceY) {
                            line.push(word);
                            addedToLine = true;
                            break;
                        }
                    }
                    
                    if (!addedToLine) {
                        lines.push([word]);
                    }
                });
                
                // Sort words within each line by x-coordinate
                lines.forEach(line => {
                    line.sort((a, b) => a.x1 - b.x1);
                });
                
                // Create quads for each line
                const quads = lines.map(line => {
                    const minX = Math.min(...line.map(w => w.x1));
                    const maxX = Math.max(...line.map(w => w.x2));
                    const minY = Math.min(...line.map(w => w.y1));
                    const maxY = Math.max(...line.map(w => w.y2));
                    
                    return {
                        x1: minX,
                        y1: minY,
                        x2: maxX,
                        y2: maxY,
                        words: line.map(w => w.text)
                    };
                });
                
                console.log('üìê Created highlight quads:', quads);
                return quads;
            }
            
            getWorkerStats() {
                return {
                    workersEnabled: this.enableWorkers,
                    activeWorkers: 0,
                    wasmVersion: wasmFunctions.get_version?.() || 'unknown'
                };
            }
            
            getBatchQueueStatus() {
                return {
                    batchOptimization: this.enableBatchOptimization,
                    queueLength: 0,
                    processing: false
                };
            }
            
            getOptimizationRecommendations() {
                return {
                    recommendations: [
                        'WASM v' + (wasmFunctions.get_version?.() || 'unknown') + ' is loaded and optimized',
                        'Word-level coordinate extraction is enabled',
                        'Fuzzy matching algorithms are active',
                        'Enhanced coordinate transformation is available'
                    ]
                };
            }
            
            getAvailableCitationFormats() {
                return ['apa', 'mla', 'chicago', 'ieee'];
            }
            
            generateCitation(match, pageObj, citationData, format = 'apa') {
                const { title, author, year, url } = citationData;
                
                switch (format.toLowerCase()) {
                    case 'apa':
                        return `${author} (${year}). ${title}. Retrieved from ${url} [Match: "${match.text}", Page ${pageObj.pageNumber}]`;
                    case 'mla':
                        return `${author}. "${title}." Web. ${new Date().getDate()} ${new Date().toLocaleString('default', { month: 'long' })} ${year}. <${url}>. [Match: "${match.text}", Page ${pageObj.pageNumber}]`;
                    case 'chicago':
                        return `${author}. "${title}." Accessed ${new Date().toLocaleDateString()}. ${url}. [Match: "${match.text}", Page ${pageObj.pageNumber}]`;
                    default:
                        return `${author}. ${title}. ${year}. ${url} [Match: "${match.text}", Page ${pageObj.pageNumber}]`;
                }
            }
            
            async annotatePage(searchQuery, pageObj, options = {}) {
                const startTime = performance.now();
                const initialized = await this.initialize();
                if (!initialized) {
                    throw new Error('Failed to initialize WASM module');
                }
                
                try {
                    let hocrContent = '';
                    
                    // Try to fetch real hOCR content if URL is provided
                    if (pageObj.hocrUrl) {
                        console.log('üîç Fetching hOCR from:', pageObj.hocrUrl);
                        try {
                            const response = await fetch(pageObj.hocrUrl);
                            if (response.ok) {
                                hocrContent = await response.text();
                                console.log('‚úÖ Successfully loaded real hOCR content');
                                console.log('üìÑ hOCR preview:', hocrContent.substring(0, 200) + '...');
                            } else {
                                console.warn(`‚ö†Ô∏è Failed to fetch hOCR (${response.status}), falling back to generated content`);
                                hocrContent = this.generateFallbackHocr(searchQuery);
                            }
                        } catch (error) {
                            console.warn('‚ö†Ô∏è Error fetching hOCR:', error.message, 'falling back to generated content');
                            hocrContent = this.generateFallbackHocr(searchQuery);
                        }
                    } else {
                        console.log('üìù No hocrUrl provided, generating fallback hOCR content');
                        hocrContent = this.generateFallbackHocr(searchQuery);
                    }
                    
                    console.log('üîç Processing search query:', searchQuery);
                    
                    // Use real WASM coordinate extraction
                    let boundingBox = null;
                    try {
                        const result = wasmFunctions.extract_bounding_box_from_hocr(hocrContent, searchQuery);
                        console.log('WASM extraction result:', result);
                        
                        if (result && typeof result === 'object' && 
                            typeof result.x1 === 'number' && typeof result.y1 === 'number' &&
                            typeof result.x2 === 'number' && typeof result.y2 === 'number' &&
                            result.x2 > result.x1 && result.y2 > result.y1) {
                            boundingBox = [result.x1, result.y1, result.x2, result.y2];
                            console.log('‚úÖ WASM extraction successful:', boundingBox);
                        } else {
                            console.warn('‚ùå WASM returned invalid coordinates:', result);
                        }
                    } catch (error) {
                        console.error('‚ùå WASM extraction failed:', error);
                    }
                    
                    if (!boundingBox) {
                        console.log('‚ö†Ô∏è WASM failed, trying legacy method...');
                        try {
                            // Generate embedded text from hOCR for legacy method
                            const embeddedText = wasmFunctions.extract_embedded_text_from_hocr 
                                ? wasmFunctions.extract_embedded_text_from_hocr(hocrContent)
                                : `[[PARAGRAPH]] [[LINE 150 250 ${150 + searchQuery.length * 10} 280]] ${searchQuery}`;
                            
                            const result = wasmFunctions.extract_bounding_box(embeddedText, searchQuery);
                            console.log('Legacy extraction result:', result);
                            
                            if (result && typeof result === 'object' && 
                                typeof result.x1 === 'number' && typeof result.y1 === 'number' &&
                                typeof result.x2 === 'number' && typeof result.y2 === 'number' &&
                                result.x2 > result.x1 && result.y2 > result.y1) {
                                boundingBox = [result.x1, result.y1, result.x2, result.y2];
                                console.log('‚úÖ Legacy extraction successful:', boundingBox);
                            } else {
                                console.warn('‚ùå Legacy also returned invalid coordinates:', result);
                            }
                        } catch (error) {
                            console.error('‚ùå Legacy extraction also failed:', error);
                        }
                    }
                    
                    if (!boundingBox) {
                        console.warn('‚ùå No text matches found in the document for query:', searchQuery);
                        const endTime = performance.now();
                        
                        // Return empty matches array instead of fake coordinates
                        return {
                            docUID: pageObj.docUID,
                            pageNumber: pageObj.pageNumber,
                            matches: [], // No matches found
                            processingTime: endTime - startTime,
                            wasmVersion: wasmFunctions.get_version(),
                            pdfData: new Blob(['mock pdf data'], { type: 'application/pdf' }),
                            message: 'No matches found for the search query in this document'
                        };
                    }
                    
                    // Use real WASM text matching for similarity
                    let similarity = 0.8;
                    try {
                        const embeddedText = `[[PARAGRAPH]] [[LINE ${boundingBox[0]} ${boundingBox[1]} ${boundingBox[2]} ${boundingBox[3]}]] ${searchQuery}`;
                        const matchResult = wasmFunctions.find_closest_match(embeddedText, searchQuery);
                        if (matchResult && typeof matchResult.similarity === 'number') {
                            similarity = matchResult.similarity;
                            console.log('‚úÖ WASM similarity score:', similarity);
                        }
                    } catch (error) {
                        console.warn('WASM text matching failed:', error);
                        similarity = 0.8; // Conservative fallback for found matches
                    }
                    
                    const endTime = performance.now();
                    const words = searchQuery.trim().split(/\s+/); // Fix undefined words variable
                    
                    // Create real PDF with WASM annotations
                    let pdfData;
                    try {
                        pdfData = await this.createAnnotatedPdf(pageObj, [{
                            text: searchQuery,
                            similarity: similarity,
                            boundingBox: boundingBox,
                            searchQuery: searchQuery,
                            startIndex: 0,
                            endIndex: words.length - 1,
                            annotationType: options.annotationType || 'rectangle',
                            formattedText: options.formattedText,
                            formatting: options.formatting
                        }], hocrContent);
                        console.log('‚úÖ Created annotated PDF with real annotations');
                    } catch (error) {
                        console.warn('‚ö†Ô∏è PDF creation failed, using fallback:', error);
                        pdfData = new Blob(['mock pdf data'], { type: 'application/pdf' });
                    }
                    
                    return {
                        docUID: pageObj.docUID,
                        pageNumber: pageObj.pageNumber,
                        matches: [{
                            text: searchQuery,
                            similarity: similarity,
                            boundingBox: boundingBox,
                            searchQuery: searchQuery,
                            startIndex: 0,
                            endIndex: words.length - 1,
                            annotationType: options.annotationType || 'rectangle'
                        }],
                        processingTime: endTime - startTime,
                        wasmVersion: wasmFunctions.get_version(),
                        pdfData: pdfData
                    };
                    
                } catch (error) {
                    console.error('WASM annotation failed:', error);
                    throw new Error(`Annotation processing failed: ${error.message}`);
                }
            }
            
            async annotatePages(searchQueries, pageObjects, options = {}) {
                const results = [];
                
                for (const pageObj of pageObjects) {
                    for (const query of searchQueries) {
                        const result = await this.annotatePage(query.text || query, pageObj, {
                            ...options,
                            annotationType: query.annotationType || options.annotationType,
                            formattedText: query.formattedText,
                            formatting: query.formatting
                        });
                        results.push(result);
                    }
                }
                
                return results;
            }
            
            async annotatePagesWithCitations(searchQueries, pageObjects, citationData, options = {}, format = 'apa') {
                const pages = await this.annotatePages(searchQueries, pageObjects, options);
                
                const citations = [];
                pages.forEach(page => {
                    page.matches.forEach(match => {
                        citations.push({
                            citation: this.generateCitation(match, { pageNumber: page.pageNumber, docUID: page.docUID }, citationData, format),
                            format: format,
                            matchText: match.text
                        });
                    });
                });
                
                const bibliography = citations.map(c => c.citation).join('\n\n');
                
                return { pages, citations, bibliography };
            }
            
            generateCitations(matches, pageObjects, citationData, format) {
                return matches.map(match => ({
                    citation: this.generateCitation(match, pageObjects[0], citationData, format),
                    format: format,
                    matchText: match.text
                }));
            }
            
            exportCitations(citations, format) {
                if (format === 'csv') {
                    const header = 'Format,Citation,MatchText\n';
                    const rows = citations.map(c => `"${c.format}","${c.citation}","${c.matchText}"`).join('\n');
                    return header + rows;
                } else if (format === 'bibtex') {
                    return citations.map((c, i) => `@misc{citation${i+1},\n  title={${c.matchText}},\n  note={${c.citation}}\n}`).join('\n\n');
                }
                return JSON.stringify(citations, null, 2);
            }
            
            generateFallbackHocr(searchQuery) {
                console.log('üìù Generating fallback hOCR content for testing purposes');
                const words = searchQuery.trim().split(/\s+/);
                let currentX = 150;
                const y1 = 250;
                const y2 = y1 + 30;
                
                // Build word spans with proper spacing
                const wordSpans = words.map(word => {
                    const x1 = currentX;
                    const x2 = x1 + (word.length * 12); // 12px per character
                    const span = `<span class='ocrx_word' title='bbox ${x1} ${y1} ${x2} ${y2}'>${word}</span>`;
                    currentX = x2 + 15; // 15px spacing
                    return span;
                });
                
                return `
                    <p class='ocr_par'>
                        <span class='ocr_line' title='bbox 100 ${y1} ${currentX} ${y2}'>
                            ${wordSpans.join('')}
                        </span>
                    </p>
                `;
            }
            
            async createAnnotatedPdf(pageObj, matches, hocrContent = '') {
                console.log('üé® Creating annotated PDF with', matches.length, 'matches using PDF-lib');
                
                // Create new PDF or load existing one
                let pdfDoc;
                if (pageObj.pdfUrl) {
                    try {
                        console.log('üìÑ Fetching original PDF from:', pageObj.pdfUrl);
                        const response = await fetch(pageObj.pdfUrl);
                        if (response.ok) {
                            const originalPdfBytes = await response.arrayBuffer();
                            pdfDoc = await PDFLib.PDFDocument.load(originalPdfBytes);
                            console.log('‚úÖ Successfully loaded original PDF');
                            
                            // Store PDF page dimensions for coordinate transformation
                            if (pdfDoc.getPageCount() > 0) {
                                const firstPage = pdfDoc.getPage(0);
                                const { width, height } = firstPage.getSize();
                                window.loadedPdfPages = [{ width, height }];
                                console.log('üìê Detected PDF page dimensions:', { width, height });
                            }
                        } else {
                            console.warn('‚ö†Ô∏è Failed to fetch PDF:', response.status, 'creating new PDF');
                            pdfDoc = await PDFLib.PDFDocument.create();
                        }
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Error loading PDF:', error.message, 'creating new PDF');
                        pdfDoc = await PDFLib.PDFDocument.create();
                    }
                } else {
                    pdfDoc = await PDFLib.PDFDocument.create();
                }
                
                // Ensure we have at least one page
                let page;
                if (pdfDoc.getPageCount() === 0) {
                    page = pdfDoc.addPage([595, 842]); // A4 size
                    const font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
                    
                    // Add sample text for demo
                    page.drawText('Document Annotation Demo\n\nThis PDF has been annotated using WASM coordinate extraction.', {
                        x: 50,
                        y: 750,
                        size: 12,
                        font: font,
                        maxWidth: 500,
                    });
                } else {
                    page = pdfDoc.getPage(Math.max(0, (pageObj.pageNumber || 1) - 1));
                }
                
                // Add annotations for each match
                for (const match of matches) {
                    if (match.boundingBox && match.boundingBox.length === 4) {
                        // Three-tier page dimension detection (priority order)
                        let hocrWidth, hocrHeight;
                        let pdfWidth = 595.0;  // Default fallback
                        let pdfHeight = 842.0; // Default fallback
                        
                        // 1. Page object properties (highest priority)
                        if (pageObj.pageWidth && pageObj.pageHeight) {
                            hocrWidth = pageObj.pageWidth;
                            hocrHeight = pageObj.pageHeight;
                            console.log('üìê Using page object dimensions:', { width: hocrWidth, height: hocrHeight });
                        }
                        // 2. Extract from hOCR data (medium priority)
                        else {
                            const hocrDimensions = extractHocrPageDimensions(hocrContent);
                            if (hocrDimensions) {
                                hocrWidth = hocrDimensions.width;
                                hocrHeight = hocrDimensions.height;
                                console.log('üìê Extracted hOCR page dimensions:', hocrDimensions);
                            } else {
                                // Will fall back to PDF detection - set to null for now
                                hocrWidth = null;
                                hocrHeight = null;
                                console.log('üìê hOCR page dimension extraction failed, will use PDF dimensions');
                            }
                        }
                        
                        // 3. Detect actual PDF page dimensions (for PDF size, and fallback for hOCR size)
                        if (window.loadedPdfPages && window.loadedPdfPages.length > 0) {
                            const firstPage = window.loadedPdfPages[0];
                            if (firstPage.width && firstPage.height) {
                                pdfWidth = firstPage.width;
                                pdfHeight = firstPage.height;
                                console.log('üìÑ Detected actual PDF dimensions:', { width: pdfWidth, height: pdfHeight });
                                
                                // If hOCR dimensions are null (extraction failed), use PDF dimensions as hOCR fallback
                                if (hocrWidth === null || hocrHeight === null) {
                                    hocrWidth = pdfWidth;
                                    hocrHeight = pdfHeight;
                                    console.log('üìê Using PDF dimensions as hOCR fallback (1:1 scale):', { width: hocrWidth, height: hocrHeight });
                                }
                            }
                        }
                        
                        // Final fallback to defaults if all detection methods failed
                        if (hocrWidth === null || hocrHeight === null) {
                            hocrWidth = 2560.0;
                            hocrHeight = 3300.0;
                            console.log('üìê All detection failed, using default hOCR dimensions:', { width: hocrWidth, height: hocrHeight });
                        }
                        
                        console.log('üìê Using coordinate transform:', {
                            pdf: [pdfWidth, pdfHeight],
                            hocr: [hocrWidth, hocrHeight],
                            scaleX: pdfWidth / hocrWidth,
                            scaleY: pdfHeight / hocrHeight
                        });
                        
                        const transform = wasmFunctions.calculate_coordinate_transform(
                            pdfWidth, pdfHeight, hocrWidth, hocrHeight
                        );
                        
                        // Transform coordinates using WASM
                        const pdfCoords = wasmFunctions.transform_coordinates(
                            match.boundingBox[0], // x1
                            match.boundingBox[1], // y1  
                            match.boundingBox[2], // x2
                            match.boundingBox[3], // y2
                            transform
                        );
                        
                        console.log('üéØ Transformed coordinates:', {
                            hOCR: match.boundingBox,
                            PDF: [pdfCoords.x, pdfCoords.y, pdfCoords.width, pdfCoords.height]
                        });
                        
                        // Get annotation color (default to red)
                        const color = this.hexToRgb(match.formatting?.color || '#ff0000');
                        const fillColor = this.hexToRgb(match.formatting?.backgroundColor || '#ffff00');
                        
                        // Create selectable annotation using a simpler approach
                        try {
                            // Create annotation dictionary manually with proper PDF objects
                            const annotRef = pdfDoc.context.nextRef();
                            const annotation = pdfDoc.context.obj({
                                Type: 'Annot',
                                Subtype: 'Square',
                                Rect: [pdfCoords.x, pdfCoords.y, pdfCoords.x + pdfCoords.width, pdfCoords.y + pdfCoords.height],
                                C: [color.r / 255, color.g / 255, color.b / 255],
                                CA: 0.8,
                                F: 4, // Print flag
                                BS: { W: 2, S: 'S' },
                                Contents: PDFLib.PDFString.of(`Text Match: ${match.text.substring(0, 100)}${match.text.length > 100 ? '...' : ''}`)
                            });
                            
                            // Register the annotation
                            pdfDoc.context.assign(annotRef, annotation);
                            
                            // Add to page annotations
                            const existingAnnots = page.node.get(PDFLib.PDFName.of('Annots'));
                            if (existingAnnots) {
                                existingAnnots.push(annotRef);
                            } else {
                                page.node.set(PDFLib.PDFName.of('Annots'), pdfDoc.context.obj([annotRef]));
                            }
                            
                            console.log('‚úÖ Created selectable annotation:', {
                                type: match.annotationType,
                                coordinates: [pdfCoords.x, pdfCoords.y, pdfCoords.width, pdfCoords.height],
                                text: match.text.substring(0, 50) + '...'
                            });
                            
                            // Add text highlight annotations if formattedText is provided and annotation type is rectangle
                            if (match.annotationType === 'rectangle' && match.formattedText && hocrContent) {
                                try {
                                    console.log('üé® Processing formatted text for highlights:', match.formattedText);
                                    
                                    // Parse formatted text to extract highlight information
                                    const highlights = this.parseFormattedText(match.formattedText);
                                    
                                    if (highlights.length > 0) {
                                        console.log(`üî§ Found ${highlights.length} highlight sections:`, highlights.map(h => h.text));
                                        
                                        // NEW OPTIMIZED APPROACH: Extract words only within the found rectangle area
                                        const wordsInArea = await this.extractWordCoordinatesFromHocr(hocrContent, match.text, match.boundingBox);
                                        
                                        if (wordsInArea.length > 0) {
                                            console.log(`üéØ Found ${wordsInArea.length} words within rectangle area`);
                                            console.log('üìù Words in area:', wordsInArea.map(w => w.text).join(' '));
                                            
                                            // Match highlight text sections to specific word coordinates
                                            const highlightCoordinates = this.matchHighlightTextToWords(wordsInArea, highlights);
                                            
                                            console.log(`üé® Created ${highlightCoordinates.length} highlight coordinate sets`);
                                            
                                            // Create text highlight annotations for each matched highlight section
                                            for (const highlightCoord of highlightCoordinates) {
                                                console.log(`‚ú® Creating multi-line highlight annotation for: "${highlightCoord.text}" with ${highlightCoord.quads.length} quads`);
                                                
                                                // Transform each quad to PDF space and collect QuadPoints
                                                const allQuadPoints = [];
                                                let overallPdfRect = null;
                                                
                                                for (let i = 0; i < highlightCoord.quads.length; i++) {
                                                    const quad = highlightCoord.quads[i];
                                                    console.log(`üìê Processing quad ${i+1}: [${quad.x1}, ${quad.y1}, ${quad.x2}, ${quad.y2}] for "${quad.text}"`);
                                                    
                                                    // Transform quad coordinates to PDF space
                                                    const quadPdfCoords = wasmFunctions.transform_coordinates(quad.x1, quad.y1, quad.x2, quad.y2, transform);
                                                    
                                                    const pdfX1 = quadPdfCoords.x;
                                                    const pdfY1 = quadPdfCoords.y;
                                                    const pdfX2 = quadPdfCoords.x + quadPdfCoords.width;
                                                    const pdfY2 = quadPdfCoords.y + quadPdfCoords.height;
                                                    
                                                    // Add QuadPoints for this quad (each quad needs 8 values: x1,y2,x2,y2,x1,y1,x2,y1)
                                                    allQuadPoints.push(pdfX1, pdfY2, pdfX2, pdfY2, pdfX1, pdfY1, pdfX2, pdfY1);
                                                    
                                                    console.log(`üìç Quad ${i+1} PDF coords: [${pdfX1.toFixed(2)}, ${pdfY1.toFixed(2)}, ${pdfX2.toFixed(2)}, ${pdfY2.toFixed(2)}]`);
                                                    
                                                    // Update overall bounding rectangle
                                                    if (overallPdfRect === null) {
                                                        overallPdfRect = [pdfX1, pdfY1, pdfX2, pdfY2];
                                                    } else {
                                                        overallPdfRect[0] = Math.min(overallPdfRect[0], pdfX1); // min x
                                                        overallPdfRect[1] = Math.min(overallPdfRect[1], pdfY1); // min y
                                                        overallPdfRect[2] = Math.max(overallPdfRect[2], pdfX2); // max x
                                                        overallPdfRect[3] = Math.max(overallPdfRect[3], pdfY2); // max y
                                                    }
                                                }
                                                
                                                console.log(`üì¶ Overall PDF Rect: [${overallPdfRect.map(v => v.toFixed(2)).join(', ')}]`);
                                                console.log(`üìê QuadPoints array length: ${allQuadPoints.length} (${allQuadPoints.length/8} quads)`);
                                                
                                                // Create text highlight annotation with multiple quads
                                                const highlightAnnotRef = pdfDoc.context.nextRef();
                                                const highlightAnnotation = pdfDoc.context.obj({
                                                    Type: 'Annot',
                                                    Subtype: 'Highlight',
                                                    Rect: overallPdfRect, // Overall bounding rectangle
                                                    QuadPoints: allQuadPoints, // Array of all quad points for multi-line highlighting
                                                    C: [highlightCoord.color.r / 255, highlightCoord.color.g / 255, highlightCoord.color.b / 255],
                                                    CA: 0.5, // Transparency
                                                    F: 4, // Print flag
                                                    Contents: PDFLib.PDFString.of(`Multi-line Highlight: ${highlightCoord.text}`)
                                                });
                                                
                                                // Register the highlight annotation
                                                pdfDoc.context.assign(highlightAnnotRef, highlightAnnotation);
                                                
                                                // Add to page annotations
                                                const existingAnnots = page.node.get(PDFLib.PDFName.of('Annots'));
                                                if (existingAnnots) {
                                                    existingAnnots.push(highlightAnnotRef);
                                                } else {
                                                    page.node.set(PDFLib.PDFName.of('Annots'), pdfDoc.context.obj([highlightAnnotRef]));
                                                }
                                                
                                                console.log(`‚úÖ Created multi-line highlight annotation for "${highlightCoord.text}" with ${highlightCoord.quads.length} quads and ${highlightCoord.wordCount} words`);
                                            }
                                        } else {
                                            console.warn('‚ö†Ô∏è No words found within rectangle area for highlighting');
                                        }
                                    } else {
                                        console.log('‚ÑπÔ∏è No background-color highlights found in formatted text');
                                    }
                                } catch (highlightError) {
                                    console.warn('‚ö†Ô∏è Failed to create text highlight annotations:', highlightError);
                                }
                            }
                        } catch (annotError) {
                            console.warn('‚ö†Ô∏è Failed to create selectable annotation, falling back to visual rectangle:', annotError);
                            // Fallback to visual rectangle if annotation creation fails
                            page.drawRectangle({
                                x: pdfCoords.x,
                                y: pdfCoords.y,
                                width: pdfCoords.width,
                                height: pdfCoords.height,
                                borderColor: PDFLib.rgb(color.r / 255, color.g / 255, color.b / 255),
                                borderWidth: 2,
                                opacity: 0.1
                            });
                        }
                    }
                }
                
                // Generate PDF bytes and return as blob
                const pdfBytes = await pdfDoc.save();
                
                // Count actual annotations on the page
                const pageAnnots = page.node.get(PDFLib.PDFName.of('Annots'));
                const annotationCount = pageAnnots ? pageAnnots.size() : 0;
                console.log('‚úÖ Generated PDF with', annotationCount, 'annotations,', pdfBytes.length, 'bytes');
                
                return new Blob([pdfBytes], { type: 'application/pdf' });
            }
            
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 255, g: 0, b: 0 }; // default to red
            }
        }

        // Extract hOCR page dimensions from ocr_page element
        function extractHocrPageDimensions(hocrContent) {
            try {
                // Convert to string if needed
                let hocrString;
                if (typeof hocrContent === 'string') {
                    hocrString = hocrContent;
                } else if (hocrContent && typeof hocrContent.outerHTML === 'string') {
                    hocrString = hocrContent.outerHTML;
                } else if (hocrContent && typeof hocrContent.innerHTML === 'string') {
                    hocrString = hocrContent.innerHTML;
                } else if (hocrContent && typeof hocrContent.textContent === 'string') {
                    hocrString = hocrContent.textContent;
                } else {
                    console.warn('hocrContent is not a string or HTML element:', typeof hocrContent);
                    return null;
                }
                
                // Look for ocr_page element with bbox attribute
                const pageMatch = hocrString.match(/<div[^>]*class=['"]*ocr_page['"]*[^>]*title=['"]*[^'"]*bbox\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)[^'"]*['"]*[^>]*>/);
                
                if (pageMatch) {
                    const x1 = parseInt(pageMatch[1]);
                    const y1 = parseInt(pageMatch[2]);
                    const x2 = parseInt(pageMatch[3]);
                    const y2 = parseInt(pageMatch[4]);
                    
                    // Page dimensions are x2-x1, y2-y1 (but typically x1=0, y1=0)
                    const width = x2 - x1;
                    const height = y2 - y1;
                    
                    if (width > 0 && height > 0) {
                        return { width, height, source: 'ocr_page_bbox' };
                    }
                }
                
                console.warn('Could not extract page dimensions from hOCR content');
                return null;
            } catch (error) {
                console.error('Error extracting hOCR page dimensions:', error);
                console.error('hocrContent type:', typeof hocrContent);
                console.error('hocrContent value:', hocrContent);
                return null;
            }
        }

        async function initializeSystem() {
            try {
                updateStatus('Initializing WASM Document Annotator...', 'info');
                
                documentAnnotator = new DocumentAnnotator(true, false, true);
                const initialized = await documentAnnotator.initialize();
                
                if (initialized) {
                    const version = wasmFunctions.get_version();
                    updateStatus(`‚úÖ WASM System v${version} initialized successfully!`, 'success');
                } else {
                    throw new Error('WASM initialization failed');
                }
                
                document.getElementById('initBtn').textContent = 'Reinitialize';
            } catch (error) {
                updateStatus(`‚ùå Initialization failed: ${error.message}`, 'error');
                console.error('Initialization error:', error);
            }
        }

        async function testWasmModule() {
            try {
                if (!documentAnnotator) {
                    throw new Error('System not initialized');
                }
                
                const isWorking = await documentAnnotator.testWasm();
                showResults('testResults', {
                    wasmModuleWorking: isWorking,
                    message: isWorking ? 'WASM module is working correctly' : 'WASM module test failed'
                });
            } catch (error) {
                showResults('testResults', { error: error.message });
            }
        }

        async function testCacheSystem() {
            try {
                if (!documentAnnotator) {
                    throw new Error('System not initialized');
                }
                
                // Test cache operations
                await documentAnnotator.clearCache();
                const stats = await documentAnnotator.getCacheStats();
                
                showResults('testResults', {
                    cacheCleared: true,
                    cacheStats: stats
                });
            } catch (error) {
                showResults('testResults', { error: error.message });
            }
        }

        async function testRichTextParser() {
            try {
                const testQuery = '<strong style="color: red;">Important Text</strong>';
                const parsed = documentAnnotator.parseRichTextQueries([testQuery]);
                
                showResults('testResults', {
                    originalQuery: testQuery,
                    parsedResult: parsed
                });
            } catch (error) {
                showResults('testResults', { error: error.message });
            }
        }

        async function testWorkerManager() {
            try {
                if (!documentAnnotator) {
                    throw new Error('System not initialized');
                }
                
                const stats = documentAnnotator.getWorkerStats();
                showResults('testResults', {
                    workerStats: stats
                });
            } catch (error) {
                showResults('testResults', { error: error.message });
            }
        }

        async function testBatchProcessor() {
            try {
                if (!documentAnnotator) {
                    throw new Error('System not initialized');
                }
                
                const queueStatus = documentAnnotator.getBatchQueueStatus();
                showResults('testResults', {
                    batchQueueStatus: queueStatus
                });
            } catch (error) {
                showResults('testResults', { error: error.message });
            }
        }

        async function testCitationGenerator() {
            try {
                if (!documentAnnotator) {
                    throw new Error('System not initialized');
                }
                
                // Test citation formats
                const availableFormats = documentAnnotator.getAvailableCitationFormats();
                
                // Create realistic match using WASM coordinate extraction
                const testQuery = "confidential information";
                const sampleHOCR = `<p class='ocr_par'>
                    <span class='ocr_line' title='bbox 100 300 500 330'>
                        <span class='ocrx_word' title='bbox 150 300 280 330'>confidential</span>
                        <span class='ocrx_word' title='bbox 290 300 420 330'>information</span>
                    </span>
                </p>`;
                
                // Use real WASM for coordinate extraction
                let boundingBox = [150, 300, 420, 330]; // default
                try {
                    const result = wasmFunctions.extract_bounding_box_from_hocr(sampleHOCR, testQuery);
                    if (result) {
                        boundingBox = [result.x1, result.y1, result.x2, result.y2];
                    }
                } catch (error) {
                    console.warn('Using fallback coordinates for citation test');
                }
                
                const mockMatch = {
                    text: testQuery,
                    similarity: 0.95,
                    boundingBox: boundingBox,
                    pageNumber: 1,
                    docUID: "test_doc_001",
                    searchQuery: testQuery,
                    startIndex: 150,
                    endIndex: 172,
                    annotationType: "highlight",
                    formatting: { backgroundColor: "#ffeb3b" }
                };

                const mockPageObj = {
                    hocrUrl: "https://example.com/test.hocr",
                    pdfUrl: "https://example.com/test.pdf",
                    docUID: "test_doc_001",
                    pageNumber: 1
                };

                const citationData = {
                    title: "Test Document",
                    author: "Test Author",
                    organization: "Test Organization",
                    year: 2024,
                    url: "https://example.com/test.pdf"
                };

                // Generate citations in different formats
                const apaCitation = documentAnnotator.generateCitation(mockMatch, mockPageObj, citationData, 'apa');
                const mlaCitation = documentAnnotator.generateCitation(mockMatch, mockPageObj, citationData, 'mla');
                const chicagoCitation = documentAnnotator.generateCitation(mockMatch, mockPageObj, citationData, 'chicago');

                showResults('testResults', {
                    availableFormats: availableFormats,
                    sampleCitations: {
                        apa: apaCitation,
                        mla: mlaCitation,
                        chicago: chicagoCitation
                    }
                });
            } catch (error) {
                showResults('testResults', { error: error.message });
            }
        }

        async function getCacheStats() {
            try {
                if (!documentAnnotator) {
                    throw new Error('System not initialized');
                }
                
                const stats = await documentAnnotator.getCacheStats();
                showResults('metricsResults', stats);
            } catch (error) {
                showResults('metricsResults', { error: error.message });
            }
        }

        async function getWorkerStats() {
            try {
                if (!documentAnnotator) {
                    throw new Error('System not initialized');
                }
                
                const stats = documentAnnotator.getWorkerStats();
                showResults('metricsResults', stats);
            } catch (error) {
                showResults('metricsResults', { error: error.message });
            }
        }

        async function getBatchStats() {
            try {
                if (!documentAnnotator) {
                    throw new Error('System not initialized');
                }
                
                const queueStatus = documentAnnotator.getBatchQueueStatus();
                showResults('metricsResults', queueStatus);
            } catch (error) {
                showResults('metricsResults', { error: error.message });
            }
        }

        async function getOptimizationRecommendations() {
            try {
                if (!documentAnnotator) {
                    throw new Error('System not initialized');
                }
                
                const recommendations = documentAnnotator.getOptimizationRecommendations();
                showResults('metricsResults', recommendations);
            } catch (error) {
                showResults('metricsResults', { error: error.message });
            }
        }

        async function parseRichText() {
            try {
                const query = document.getElementById('richTextQuery').value;
                if (!query) {
                    throw new Error('Please enter a rich text query');
                }
                
                const parsed = documentAnnotator.parseRichTextQueries([query]);
                showResults('exampleResults', {
                    originalQuery: query,
                    parsedResult: parsed
                });
            } catch (error) {
                showResults('exampleResults', { error: error.message });
            }
        }

        async function mockAnnotation() {
            try {
                const hocrContent = document.getElementById('hocrContent').value;
                const richQuery = document.getElementById('richTextQuery').value || 'important text';
                
                // This would be a real annotation process in a full implementation
                const mockResult = {
                    searchQuery: richQuery,
                    hocrContent: hocrContent.substring(0, 100) + '...',
                    mockMatches: [
                        {
                            text: 'important sample text',
                            similarity: 0.85,
                            boundingBox: [100, 100, 400, 130],
                            annotationType: 'rectangle'
                        }
                    ],
                    note: 'This is a mock result. Full implementation requires PDF and hOCR URLs.'
                };
                
                showResults('exampleResults', mockResult);
            } catch (error) {
                showResults('exampleResults', { error: error.message });
            }
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            updateStatus('Ready to initialize. Click "Initialize System" to begin.', 'info');
            initializePlayground();
            attachPlaygroundEventListeners();
        });

        // =============================================================================
        // INTERACTIVE CODE PLAYGROUND
        // =============================================================================

        // Sample Firebase URLs (replace with your actual demo URLs)
        const SAMPLE_FIREBASE_URLS = {
            legalContract: {
                pageObjects: [
                    {
                        hocrUrl: "https://firebasestorage.googleapis.com/v0/b/demo-project/o/samples%2Flegal-contract-page1.hocr?alt=media&token=demo-token-1",
                        pdfUrl: "https://firebasestorage.googleapis.com/v0/b/demo-project/o/samples%2Flegal-contract.pdf?alt=media&token=demo-token-2",
                        docUID: "legal_contract_sample",
                        pageNumber: 1,
                        metadata: { type: "contract", confidential: true }
                    }
                ],
                searchQueries: [
                    {
                        text: "confidential information",
                        annotationType: "highlight",
                        formatting: { backgroundColor: "#ffeb3b", color: "#d32f2f" }
                    }
                ]
            },
            medicalReport: {
                pageObjects: [
                    {
                        hocrUrl: "https://firebasestorage.googleapis.com/v0/b/demo-project/o/samples%2Fmedical-report.hocr?alt=media&token=demo-token-3",
                        pdfUrl: "https://firebasestorage.googleapis.com/v0/b/demo-project/o/samples%2Fmedical-report.pdf?alt=media&token=demo-token-4",
                        docUID: "medical_report_sample",
                        pageNumber: 1,
                        metadata: { type: "medical", patient: "anonymous" }
                    }
                ],
                searchQueries: [
                    {
                        text: "patient diagnosis",
                        annotationType: "rectangle",
                        formatting: { color: "#1976d2" }
                    }
                ]
            }
        };

        // Playground state
        let currentEditor = null;
        let lastExecutionResult = null;

        function initializePlayground() {
            // Initialize the code editor as a textarea for now
            // In a real implementation, you'd use Monaco Editor or CodeMirror
            const editor = document.getElementById('codeEditor');
            if (!editor) {
                console.log('Code editor element not found, skipping playground initialization');
                return;
            }
            
            editor.innerHTML = '<textarea id="codeTextarea" style="width: 100%; height: 100%; background: #1e1e1e; color: #d4d4d4; border: none; padding: 20px; font-family: Monaco, monospace; resize: none;"></textarea>';
            
            currentEditor = document.getElementById('codeTextarea');
            
            // Set initial example
            loadExample('basic');
            
            console.log('Interactive Code Playground initialized successfully');
        }

        // Code examples for different scenarios
        const CODE_EXAMPLES = {
            basic: `// Basic Firebase URL Example
const annotator = new DocumentAnnotator(true, false, true);

// Use the sample legal contract data
const result = await annotator.annotatePages(
    legalContract.searchQueries,
    legalContract.pageObjects,
    {
        tolerance: 0.8,
        enableCaching: true,
        outputFormat: 'blob'
    }
);

console.log('Processing complete!');
console.log('Pages processed:', result.length);
console.log('First page matches:', result[0].matches.length);
return result;`,

            formattedText: `// Formatted Text Highlighting Example
const annotator = new DocumentAnnotator(true, false, true);

// Define search query with formatted text highlighting
const mySearchQueries = [{
    text: "(54) CIRCUIT AND METHOD FOR OPERATING A CIRCUIT",
    formattedText: "<strong>(54) </strong><strong style=\\"background-color: rgb(254, 255, 1);\\">CIRCUIT AND METHOD</strong><strong> FOR </strong><strong style=\\"background-color: rgb(109, 217, 255);\\">OPERATING A CIRCUIT</strong>",
    annotationType: "rectangle",
    formatting: {
        color: "#ff0000",
        backgroundColor: "#ffff00"
    }
}];

// Use sample page object (or your own Firebase URLs)
const myPageObject = {
    hocrUrl: "https://firebasestorage.googleapis.com/v0/b/demo-project/o/samples%2Fpatent-page1.hocr?alt=media&token=demo-token-5",
    pdfUrl: "https://firebasestorage.googleapis.com/v0/b/demo-project/o/samples%2Fpatent.pdf?alt=media&token=demo-token-6",
    docUID: "patent_sample",
    pageNumber: 1
};

// Process the document with text highlighting
const result = await annotator.annotatePages(
    mySearchQueries,
    [myPageObject],
    {
        tolerance: 0.8,
        maxResults: 10,
        enableCaching: true,
        outputFormat: 'blob'
    }
);

console.log('üìÑ Document processed with rectangle and text highlights!');
console.log('üì¶ Rectangle annotation created for entire text');
console.log('üé® Text highlight annotations created for:');
console.log('  - "CIRCUIT AND METHOD" (yellow background)');
console.log('  - "OPERATING A CIRCUIT" (blue background)');
console.log('‚ú® Generated PDF contains both selectable rectangle and text highlights');

return result;`,

            multiQuery: `// Multi-Query Firebase Example
const annotator = new DocumentAnnotator(true, true, true);

// Combine multiple sample document types
const allPageObjects = [
    ...legalContract.pageObjects,
    ...medicalReport.pageObjects
];

const searchQueries = [
    {
        text: "confidential",
        annotationType: "highlight",
        formatting: { backgroundColor: "#ffeb3b" }
    },
    {
        text: "patient",
        annotationType: "rectangle",
        formatting: { color: "#e91e63" }
    }
];

const results = await annotator.annotatePages(
    searchQueries,
    allPageObjects,
    {
        tolerance: 0.85,
        enableCaching: true,
        parallelProcessing: true,
        outputFormat: 'blob'
    }
);

// Analyze results
results.forEach(page => {
    console.log(\`Document: \${page.docUID}\`);
    console.log(\`Matches found: \${page.matches.length}\`);
    console.log(\`Processing time: \${page.processingTime}ms\`);
});

return results;`,

            legal: `// Legal Document Search Example
const annotator = new DocumentAnnotator(true, false, true);

const legalSearchQueries = [
    {
        text: "confidential information",
        annotationType: "highlight",
        formatting: { 
            backgroundColor: "#fff59d", 
            color: "#e65100" 
        }
    },
    {
        text: "agreement",
        annotationType: "underline",
        formatting: { color: "#1976d2" }
    }
];

const results = await annotator.annotatePages(
    legalSearchQueries,
    legalContract.pageObjects,
    {
        tolerance: 0.9,  // High accuracy for legal text
        maxResults: 15,
        enableCaching: true,
        outputFormat: 'blob'
    }
);

console.log('Legal document analysis complete');
console.log('Confidential items found:', 
    results[0].matches.filter(m => m.searchQuery.includes('confidential')).length
);

return results;`,

            medical: `// Medical Report Analysis Example
const annotator = new DocumentAnnotator(true, false, true);

const medicalSearchQueries = [
    {
        text: "patient",
        annotationType: "rectangle",
        formatting: { color: "#d32f2f" }
    },
    {
        text: "diagnosis",
        annotationType: "highlight",
        formatting: { 
            backgroundColor: "#e1f5fe",
            color: "#0277bd" 
        }
    }
];

const results = await annotator.annotatePages(
    medicalSearchQueries,
    medicalReport.pageObjects,
    {
        tolerance: 0.85,
        maxResults: 20,
        enableCaching: true,
        outputFormat: 'blob'
    }
);

console.log('Medical report analysis complete');
results.forEach(page => {
    console.log(\`Page \${page.pageNumber}: \${page.matches.length} medical terms found\`);
});

return results;`,

            citation: `// Citation Generation Example
const annotator = new DocumentAnnotator(true, false, true);

const searchQueries = [
    {
        text: "confidential information",
        annotationType: "highlight",
        formatting: { backgroundColor: "#ffeb3b", color: "#d32f2f" }
    },
    {
        text: "agreement",
        annotationType: "underline", 
        formatting: { color: "#1976d2" }
    }
];

// Citation metadata
const citationData = {
    title: "Legal Service Agreement",
    author: "Legal Department",
    organization: "Law Firm Associates",
    year: 2024,
    url: "https://example.com/legal-contract.pdf",
    date: "January 15, 2024"
};

// Annotate pages and generate citations
const result = await annotator.annotatePagesWithCitations(
    searchQueries,
    legalContract.pageObjects,
    citationData,
    {
        tolerance: 0.7,
        enableCaching: true,
        outputFormat: 'blob'
    },
    'apa' // citation format
);

console.log('\\n=== ANNOTATION RESULTS ===');
console.log(\`Found \${result.pages[0].matches.length} matches on page 1\`);
result.pages[0].matches.forEach((match, i) => {
    console.log(\`Match \${i+1}: "\${match.text}" (similarity: \${match.similarity.toFixed(2)})\`);
});

console.log('\\n=== CITATIONS ===');
result.citations.forEach((citation, i) => {
    console.log(\`Citation \${i+1} (\${citation.format}):\`);
    console.log(citation.citation);
    console.log(\`Text: "\${citation.matchText}"\`);
    console.log('---');
});

console.log('\\n=== BIBLIOGRAPHY ===');
console.log(result.bibliography);

return {
    annotatedPages: result.pages,
    citations: result.citations,
    bibliography: result.bibliography
};`,

            custom: `// Custom Firebase URLs - Replace with your own!
const annotator = new DocumentAnnotator(true, true, true);

const customPageObjects = [
    {
        hocrUrl: "https://firebasestorage.googleapis.com/v0/b/YOUR-PROJECT/o/YOUR-FILE.hocr?alt=media&token=YOUR-TOKEN",
        pdfUrl: "https://firebasestorage.googleapis.com/v0/b/YOUR-PROJECT/o/YOUR-FILE.pdf?alt=media&token=YOUR-TOKEN",
        docUID: "your_document_id",
        pageNumber: 1
    }
];

const searchQueries = [
    {
        text: "your search text",
        annotationType: "highlight",
        formatting: { backgroundColor: "#ffeb3b" }
    }
];

const results = await annotator.annotatePages(
    searchQueries,
    customPageObjects,
    {
        tolerance: 0.8,
        enableCaching: true,
        outputFormat: 'blob'
    }
);

console.log('Your results:', results);
return results;`
        };

        function loadExample(exampleKey) {
            if (CODE_EXAMPLES[exampleKey] && currentEditor) {
                currentEditor.value = CODE_EXAMPLES[exampleKey];
            }
        }

        async function executeCode() {
            const codeTextarea = document.getElementById('codeTextarea');
            const resultsOutput = document.getElementById('resultsOutput');
            const executionStatus = document.getElementById('executionStatus');
            const runButton = document.getElementById('runCode');
            
            if (!codeTextarea || !codeTextarea.value.trim()) {
                updateExecutionStatus('No code to execute', 'error');
                return;
            }
            
            try {
                // Update UI to show execution in progress
                updateExecutionStatus('Executing...', 'executing');
                runButton.disabled = true;
                
                const startTime = performance.now();
                
                // Make sample data available in execution context
                window.legalContract = SAMPLE_FIREBASE_URLS.legalContract;
                window.medicalReport = SAMPLE_FIREBASE_URLS.medicalReport;
                
                // Make DocumentAnnotator available globally for code execution
                window.DocumentAnnotator = DocumentAnnotator;
                
                // Execute the code - wrap in async function to support await
                const func = new Function(`
                    return (async function() {
                        ${codeTextarea.value}
                    })();
                `);
                
                const result = await func();
                const endTime = performance.now();
                const executionTime = Math.round(endTime - startTime);
                
                // Display successful result
                updateExecutionStatus(`Completed in ${executionTime}ms`, 'success');
                displayExecutionResult(result, executionTime, true);
                
                lastExecutionResult = result;
                
            } catch (error) {
                console.error('Code execution error:', error);
                updateExecutionStatus('Execution failed', 'error');
                displayExecutionResult(error, 0, false);
            } finally {
                runButton.disabled = false;
            }
        }

        function updateExecutionStatus(message, type) {
            const executionStatus = document.getElementById('executionStatus');
            if (executionStatus) {
                executionStatus.textContent = message;
                executionStatus.className = `status-indicator ${type}`;
            }
        }

        function displayExecutionResult(result, executionTime, success) {
            const resultsOutput = document.getElementById('resultsOutput');
            if (!resultsOutput) return;
            
            if (success) {
                const resultHtml = `
                    <div class="execution-result execution-success">
                        <div class="execution-stats">
                            <span>‚è±Ô∏è Execution Time: ${executionTime}ms</span>
                            <span>üìä Status: Success</span>
                            <span>üîß WASM Version: ${wasmFunctions.get_version?.() || 'unknown'}</span>
                        </div>
                        <h4>üìã Result:</h4>
                        ${formatExecutionResult(result)}
                    </div>
                `;
                resultsOutput.innerHTML = resultHtml;
            } else {
                const errorHtml = `
                    <div class="execution-result execution-error">
                        <h4>‚ùå Execution Error:</h4>
                        <p><strong>Message:</strong> ${result.message || result.toString()}</p>
                        ${result.stack ? `<p><strong>Stack:</strong></p><pre>${result.stack}</pre>` : ''}
                    </div>
                `;
                resultsOutput.innerHTML = errorHtml;
            }
        }

        function formatExecutionResult(result) {
            if (!result) return '<p>No result returned</p>';
            
            if (Array.isArray(result) && result.length > 0 && result[0].matches) {
                // Format annotation results
                let html = '<div class="results-summary">';
                html += `<p><strong>üìÑ Pages Processed:</strong> ${result.length}</p>`;
                
                result.forEach((page, i) => {
                    html += `
                        <div class="page-result">
                            <h4>üìÑ Page ${page.pageNumber || i + 1} (${page.docUID || 'unknown'})</h4>
                            <div class="match-summary">
                                <span>üéØ Matches: ${page.matches.length}</span>
                                <span>‚è±Ô∏è Processing: ${Math.round(page.processingTime || 0)}ms</span>
                                <span>üîß WASM: ${page.wasmVersion || 'unknown'}</span>
                            </div>
                            <div class="matches-list">
                    `;
                    
                    page.matches.forEach((match, j) => {
                        html += `
                            <div class="match-item">
                                <span class="match-text">"${match.text.substring(0, 40)}${match.text.length > 40 ? '...' : ''}"</span>
                                <span class="similarity">${(match.similarity * 100).toFixed(1)}%</span>
                                <span class="annotation-type">${match.annotationType || 'rectangle'}</span>
                            </div>
                        `;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                return html;
            } else if (result.annotatedPages || result.citations) {
                // Format citation results
                let html = '<div class="results-summary">';
                html += `<p><strong>üìö Citations Generated:</strong> ${result.citations?.length || 0}</p>`;
                
                if (result.citations) {
                    html += '<h4>üìñ Citations:</h4>';
                    result.citations.forEach((citation, i) => {
                        html += `
                            <div class="page-result">
                                <p><strong>Citation ${i + 1} (${citation.format}):</strong></p>
                                <p style="font-style: italic;">${citation.citation}</p>
                                <p><strong>Match Text:</strong> "${citation.matchText}"</p>
                            </div>
                        `;
                    });
                }
                
                if (result.bibliography) {
                    html += '<h4>üìö Bibliography:</h4>';
                    html += `<pre style="background: #f8f9fa; padding: 10px; border-radius: 4px;">${result.bibliography}</pre>`;
                }
                
                html += '</div>';
                return html;
            } else {
                // Format other results as JSON
                return `<pre style="background: #f8f9fa; padding: 15px; border-radius: 4px; overflow-x: auto;">${JSON.stringify(result, null, 2)}</pre>`;
            }
        }

        function resetCode() {
            const exampleSelect = document.getElementById('exampleSelect');
            if (exampleSelect) {
                loadExample(exampleSelect.value);
            }
        }

        function copyResult() {
            if (lastExecutionResult) {
                navigator.clipboard.writeText(JSON.stringify(lastExecutionResult, null, 2));
                alert('Result copied to clipboard!');
            }
        }

        // Attach event listeners for playground functionality
        function attachPlaygroundEventListeners() {
            const exampleSelect = document.getElementById('exampleSelect');
            const runButton = document.getElementById('runCode');
            const resetButton = document.getElementById('resetCode');
            const copyButton = document.getElementById('copyResult');
            
            if (exampleSelect) {
                exampleSelect.addEventListener('change', (e) => {
                    loadExample(e.target.value);
                });
            }
            
            if (runButton) {
                runButton.addEventListener('click', executeCode);
            }
            
            if (resetButton) {
                resetButton.addEventListener('click', resetCode);
            }
            
            if (copyButton) {
                copyButton.addEventListener('click', copyResult);
            }
        }

        // Make functions available globally
        window.initializeSystem = initializeSystem;
        window.testWasmModule = testWasmModule;
        window.testCacheSystem = testCacheSystem;
        window.testRichTextParser = testRichTextParser;
        window.testWorkerManager = testWorkerManager;
        window.testBatchProcessor = testBatchProcessor;
        window.testCitationGenerator = testCitationGenerator;
        window.getCacheStats = getCacheStats;
        window.getWorkerStats = getWorkerStats;
        window.getBatchStats = getBatchStats;
        window.getOptimizationRecommendations = getOptimizationRecommendations;
        window.parseRichText = parseRichText;
        window.mockAnnotation = mockAnnotation;
    </script>
</body>
</html>
