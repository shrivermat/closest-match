import { PDFAnnotator } from './pdf-annotator';
import { CacheManager } from './cache-manager';
import { RichTextParser } from './rich-text-parser';
import { WorkerManager } from './worker-manager';
import { BatchProcessor } from './batch-processor';
import { CitationGenerator, type CitationData, type CitationResult } from './citation-generator';
import type {
  SearchQuery,
  PageObject,
  ProcessingOptions,
  MatchResult,
  AnnotatedPage,
  BoundingBox,
  WasmMatchResult,
  WasmBoundingBox
} from './types';

// Import WASM module (will be generated by wasm-pack)
let wasmModule: any = null;

export class DocumentAnnotator {
  private wasmInitialized = false;
  private pdfAnnotator: PDFAnnotator;
  private cacheManager: CacheManager;
  private workerManager?: WorkerManager;
  private batchProcessor: BatchProcessor;

  constructor(enableCaching = true, enableWorkers = false, enableBatchOptimization = true) {
    this.pdfAnnotator = new PDFAnnotator();
    this.cacheManager = new CacheManager();
    this.batchProcessor = new BatchProcessor({
      enableAdaptiveOptimization: enableBatchOptimization,
      maxConcurrentJobs: enableWorkers ? 5 : 2
    });
    
    if (enableCaching) {
      this.initializeCache();
    }
    
    if (enableWorkers && typeof Worker !== 'undefined') {
      this.initializeWorkers();
    }
    
    this.initializeWasm();
  }

  private async initializeWasm(): Promise<void> {
    try {
      // Dynamic import of the WASM module
      const wasmModuleImport = await import('../pkg/document_annotator');
      // Initialize the WASM module
      await wasmModuleImport.default();
      wasmModule = wasmModuleImport;
      this.wasmInitialized = true;
      console.log('WASM module initialized successfully');
    } catch (error) {
      console.error('Failed to initialize WASM module:', error);
      throw new Error('WASM initialization failed');
    }
  }

  private async initializeCache(): Promise<void> {
    try {
      await this.cacheManager.initialize();
      console.log('Cache manager initialized successfully');
    } catch (error) {
      console.error('Failed to initialize cache manager:', error);
      // Continue without caching if initialization fails
    }
  }

  private async initializeWorkers(): Promise<void> {
    try {
      this.workerManager = new WorkerManager({
        maxWorkers: Math.max(2, Math.min(6, navigator.hardwareConcurrency || 4)),
        workerScript: '/dist/document-worker.js'
      });
      await this.workerManager.initialize();
      console.log('Worker manager initialized successfully');
    } catch (error) {
      console.error('Failed to initialize worker manager:', error);
      this.workerManager = undefined;
      // Continue without workers if initialization fails
    }
  }

  private async ensureWasmInitialized(): Promise<void> {
    if (!this.wasmInitialized) {
      await this.initializeWasm();
    }
  }

  // Core API method as specified in the implementation plan
  async annotatePages(
    searchQueries: SearchQuery[],
    pageObjects: PageObject[],
    options: ProcessingOptions = {
      tolerance: 0.8,
      maxResults: 10,
      enableCaching: false,
      outputFormat: 'blob',
      parallelProcessing: false
    }
  ): Promise<AnnotatedPage[]> {
    await this.ensureWasmInitialized();

    const results: AnnotatedPage[] = [];
    
    for (const pageObj of pageObjects) {
      const startTime = performance.now();
      
      try {
        const annotatedPage = await this.processPage(pageObj, searchQueries, options);
        annotatedPage.processingTime = performance.now() - startTime;
        results.push(annotatedPage);
      } catch (error) {
        console.error(`Failed to process page ${pageObj.pageNumber} of ${pageObj.docUID}:`, error);
        // Continue processing other pages
      }
    }

    return results;
  }

  private async processPage(
    pageObj: PageObject,
    searchQueries: SearchQuery[],
    options: ProcessingOptions
  ): Promise<AnnotatedPage> {
    // Generate cache keys
    const hocrCacheKey = CacheManager.generateHocrKey(pageObj.hocrUrl, pageObj.docUID, pageObj.pageNumber);
    const pdfCacheKey = CacheManager.generatePdfKey(pageObj.pdfUrl, pageObj.docUID);

    let embeddedText: string;
    let pdfBytes: ArrayBuffer;

    // Try to get embedded text from cache
    if (options.enableCaching) {
      const cachedEmbeddedText = await this.cacheManager.get<string>('hocr_data', hocrCacheKey);
      if (cachedEmbeddedText) {
        embeddedText = cachedEmbeddedText;
      } else {
        // Load and process hOCR data
        const hocrData = await this.loadResource(pageObj.hocrUrl);
        embeddedText = wasmModule.extract_embedded_text_from_hocr(hocrData);
        
        // Cache the processed embedded text
        await this.cacheManager.set('hocr_data', hocrCacheKey, embeddedText);
      }
    } else {
      // Load and process hOCR data without caching
      const hocrData = await this.loadResource(pageObj.hocrUrl);
      embeddedText = wasmModule.extract_embedded_text_from_hocr(hocrData);
    }

    // Load PDF data (caching raw PDF bytes might be too large, so we cache metadata instead)
    pdfBytes = await this.loadResource(pageObj.pdfUrl, 'arrayBuffer') as ArrayBuffer;

    // Find matches for all search queries (with caching)
    const matches = await this.findMatchesWithCache(
      embeddedText,
      searchQueries,
      pageObj,
      options.tolerance,
      options.enableCaching
    );

    // Create annotated PDF
    const annotatedPdfData = await this.createAnnotatedPdf(
      pdfBytes,
      matches,
      options.outputFormat
    );

    return {
      docUID: pageObj.docUID,
      pageNumber: pageObj.pageNumber,
      pdfData: annotatedPdfData,
      matches,
      processingTime: 0 // Will be set by caller
    };
  }

  private async findMatches(
    embeddedText: string,
    searchQueries: SearchQuery[],
    pageObj: PageObject,
    tolerance: number
  ): Promise<MatchResult[]> {
    return await this.findMatchesWithCache(embeddedText, searchQueries, pageObj, tolerance, false);
  }

  private async findMatchesWithCache(
    embeddedText: string,
    searchQueries: SearchQuery[],
    pageObj: PageObject,
    tolerance: number,
    enableCaching: boolean
  ): Promise<MatchResult[]> {
    const matches: MatchResult[] = [];

    for (const query of searchQueries) {
      let match: MatchResult | null = null;

      // Try to get from cache first
      if (enableCaching) {
        const cacheKey = CacheManager.generateMatchKey(
          query.text,
          pageObj.docUID,
          pageObj.pageNumber,
          tolerance
        );
        match = await this.cacheManager.get<MatchResult>('match_results', cacheKey);
      }

      if (!match) {
        // Use WASM function to find closest match
        const wasmResult: WasmMatchResult | null = wasmModule.find_closest_match(
          embeddedText,
          query.text
        );

        if (wasmResult && wasmResult.similarity >= tolerance) {
          // Extract bounding box using WASM
          const boundingBox: WasmBoundingBox | null = wasmModule.extract_bounding_box(
            embeddedText,
            wasmResult.text
          );

          if (boundingBox) {
            match = {
              text: wasmResult.text,
              similarity: wasmResult.similarity,
              boundingBox: [boundingBox.x1, boundingBox.y1, boundingBox.x2, boundingBox.y2],
              pageNumber: pageObj.pageNumber,
              docUID: pageObj.docUID,
              searchQuery: query.text,
              startIndex: wasmResult.start_index,
              endIndex: wasmResult.end_index,
              annotationType: query.annotationType,
              formatting: query.formatting
            };

            // Cache the result
            if (enableCaching) {
              const cacheKey = CacheManager.generateMatchKey(
                query.text,
                pageObj.docUID,
                pageObj.pageNumber,
                tolerance
              );
              await this.cacheManager.set('match_results', cacheKey, match);
            }
          }
        }
      } else if (enableCaching) {
        // Update the cached match with current query formatting
        match.annotationType = query.annotationType;
        match.formatting = query.formatting;
      }

      if (match) {
        matches.push(match);
      }
    }

    return matches;
  }

  private async createAnnotatedPdf(
    pdfBytes: ArrayBuffer,
    matches: MatchResult[],
    outputFormat: 'blob' | 'base64' | 'arrayBuffer'
  ): Promise<Blob | string | ArrayBuffer> {
    // Use the dedicated PDF annotator
    return await this.pdfAnnotator.createAnnotatedPdf(pdfBytes, matches, outputFormat);
  }

  private async loadResource(url: string, responseType: 'text' | 'arrayBuffer' = 'text'): Promise<string | ArrayBuffer> {
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`Failed to load resource: ${url} - ${response.statusText}`);
    }

    if (responseType === 'arrayBuffer') {
      return await response.arrayBuffer();
    } else {
      return await response.text();
    }
  }

  // Utility method for single page processing
  async annotatePage(
    searchQuery: string,
    pageObj: PageObject,
    options: Partial<ProcessingOptions> = {}
  ): Promise<AnnotatedPage> {
    const fullOptions: ProcessingOptions = {
      tolerance: 0.8,
      maxResults: 10,
      enableCaching: false,
      outputFormat: 'blob',
      parallelProcessing: false,
      ...options
    };

    const queries: SearchQuery[] = [{
      text: searchQuery,
      annotationType: 'rectangle'
    }];

    const results = await this.annotatePages(queries, [pageObj], fullOptions);
    return results[0];
  }

  // Method to test WASM functionality
  async testWasm(): Promise<boolean> {
    try {
      await this.ensureWasmInitialized();
      
      // Test basic string matching
      const testText = "[[PARAGRAPH]] [[LINE 100 200 300 400]] hello world test";
      const result = wasmModule.find_closest_match(testText, "hello world");
      
      return result !== null && result.similarity > 0.5;
    } catch (error) {
      console.error('WASM test failed:', error);
      return false;
    }
  }

  // PDF utility methods
  async validatePdf(pdfBytes: ArrayBuffer): Promise<{
    isValid: boolean;
    pageCount: number;
    error?: string;
  }> {
    return await this.pdfAnnotator.validatePdf(pdfBytes);
  }

  async extractPageInfo(pdfBytes: ArrayBuffer): Promise<{
    pageCount: number;
    pages: Array<{ width: number; height: number; index: number }>;
  }> {
    return await this.pdfAnnotator.extractPageInfo(pdfBytes);
  }

  // Advanced annotation with custom search queries including annotation types
  async annotatePageAdvanced(
    searchQueries: SearchQuery[],
    pageObj: PageObject,
    options: Partial<ProcessingOptions> = {}
  ): Promise<AnnotatedPage> {
    const fullOptions: ProcessingOptions = {
      tolerance: 0.8,
      maxResults: 10,
      enableCaching: false,
      outputFormat: 'blob',
      parallelProcessing: false,
      ...options
    };

    const results = await this.annotatePages(searchQueries, [pageObj], fullOptions);
    return results[0];
  }

  // Batch processing with progress callback
  async annotatePagesWithProgress(
    searchQueries: SearchQuery[],
    pageObjects: PageObject[],
    options: ProcessingOptions = {
      tolerance: 0.8,
      maxResults: 10,
      enableCaching: false,
      outputFormat: 'blob',
      parallelProcessing: false
    },
    onProgress?: (completed: number, total: number, currentPage: PageObject) => void
  ): Promise<AnnotatedPage[]> {
    await this.ensureWasmInitialized();

    // Use parallel processing if enabled and available
    if (options.parallelProcessing && this.workerManager) {
      return await this.processPagesBatch(searchQueries, pageObjects, options, onProgress);
    }

    // Sequential processing (fallback)
    const results: AnnotatedPage[] = [];
    const total = pageObjects.length;
    
    for (let i = 0; i < pageObjects.length; i++) {
      const pageObj = pageObjects[i];
      const startTime = performance.now();
      
      try {
        if (onProgress) {
          onProgress(i, total, pageObj);
        }
        
        const annotatedPage = await this.processPage(pageObj, searchQueries, options);
        annotatedPage.processingTime = performance.now() - startTime;
        results.push(annotatedPage);
        
        if (onProgress) {
          onProgress(i + 1, total, pageObj);
        }
      } catch (error) {
        console.error(`Failed to process page ${pageObj.pageNumber} of ${pageObj.docUID}:`, error);
        // Continue processing other pages
      }
    }

    return results;
  }

  // Parallel batch processing using Web Workers
  private async processPagesBatch(
    searchQueries: SearchQuery[],
    pageObjects: PageObject[],
    options: ProcessingOptions,
    onProgress?: (completed: number, total: number, currentPage: PageObject) => void
  ): Promise<AnnotatedPage[]> {
    if (!this.workerManager) {
      throw new Error('Worker manager not initialized');
    }

    const tasks = pageObjects.map(pageObj => ({
      type: 'process_page' as const,
      data: {
        pageObj,
        searchQueries,
        tolerance: options.tolerance,
        enableCaching: options.enableCaching
      },
      priority: 'medium' as const
    }));

    let completed = 0;
    const total = pageObjects.length;

    const results = await this.workerManager.processBatch(
      tasks,
      (completedCount, totalCount, result) => {
        completed = completedCount;
        if (onProgress && completedCount <= pageObjects.length) {
          const currentPage = pageObjects[completedCount - 1];
          onProgress(completedCount, total, currentPage);
        }
      }
    );

    // Convert worker results to AnnotatedPage objects
    const annotatedPages: AnnotatedPage[] = [];

    for (let i = 0; i < results.length; i++) {
      const workerResult = results[i];
      const pageObj = pageObjects[i];

      try {
        // Load PDF and create annotations
        const pdfBytes = await this.loadResource(pageObj.pdfUrl, 'arrayBuffer') as ArrayBuffer;
        const annotatedPdfData = await this.createAnnotatedPdf(
          pdfBytes,
          workerResult.matches,
          options.outputFormat
        );

        annotatedPages.push({
          docUID: pageObj.docUID,
          pageNumber: pageObj.pageNumber,
          pdfData: annotatedPdfData,
          matches: workerResult.matches,
          processingTime: 0 // Will be calculated by worker
        });
      } catch (error) {
        console.error(`Failed to create annotated PDF for ${pageObj.docUID} page ${pageObj.pageNumber}:`, error);
      }
    }

    return annotatedPages;
  }

  // Cache management methods
  async clearCache(): Promise<void> {
    await this.cacheManager.clear();
  }

  async getCacheStats(): Promise<{
    stats: import('./cache-manager').ProcessingStats;
    info: {
      totalEntries: number;
      totalSize: number;
      storeInfo: Record<string, { entries: number; size: number }>;
    };
  }> {
    const [stats, info] = await Promise.all([
      this.cacheManager.getStats(),
      this.cacheManager.getCacheInfo()
    ]);
    
    return { stats, info };
  }

  async cleanupCache(): Promise<{ removed: number; freedBytes: number }> {
    return await this.cacheManager.cleanup();
  }

  async preloadHocrData(pageObjects: PageObject[]): Promise<void> {
    const promises = pageObjects.map(async (pageObj) => {
      const cacheKey = CacheManager.generateHocrKey(pageObj.hocrUrl, pageObj.docUID, pageObj.pageNumber);
      const cached = await this.cacheManager.get('hocr_data', cacheKey);
      
      if (!cached) {
        try {
          const hocrData = await this.loadResource(pageObj.hocrUrl);
          const embeddedText = wasmModule.extract_embedded_text_from_hocr(hocrData);
          await this.cacheManager.set('hocr_data', cacheKey, embeddedText);
        } catch (error) {
          console.warn(`Failed to preload hOCR data for ${pageObj.docUID} page ${pageObj.pageNumber}:`, error);
        }
      }
    });

    await Promise.all(promises);
  }

  // Rich text processing methods
  
  /**
   * Annotate page using HTML formatted search query
   */
  async annotatePageWithHTML(
    htmlSearchQuery: string,
    pageObj: PageObject,
    options: Partial<ProcessingOptions> = {}
  ): Promise<AnnotatedPage> {
    const parsedText = RichTextParser.parseHTML(htmlSearchQuery);
    const searchQueries = RichTextParser.toSearchQueries(parsedText);
    
    return await this.annotatePageAdvanced(searchQueries, pageObj, options);
  }

  /**
   * Annotate page using RTF formatted search query
   */
  async annotatePageWithRTF(
    rtfSearchQuery: string,
    pageObj: PageObject,
    options: Partial<ProcessingOptions> = {}
  ): Promise<AnnotatedPage> {
    const parsedText = RichTextParser.parseRTF(rtfSearchQuery);
    const searchQueries = RichTextParser.toSearchQueries(parsedText);
    
    return await this.annotatePageAdvanced(searchQueries, pageObj, options);
  }

  /**
   * Annotate page using auto-detected rich text format
   */
  async annotatePageWithRichText(
    richTextQuery: string,
    pageObj: PageObject,
    options: Partial<ProcessingOptions> = {}
  ): Promise<AnnotatedPage> {
    const parsedText = RichTextParser.parseAuto(richTextQuery);
    const searchQueries = RichTextParser.toSearchQueries(parsedText);
    
    return await this.annotatePageAdvanced(searchQueries, pageObj, options);
  }

  /**
   * Annotate multiple pages using rich text queries
   */
  async annotatePagesWithRichText(
    richTextQueries: string[],
    pageObjects: PageObject[],
    options: ProcessingOptions = {
      tolerance: 0.8,
      maxResults: 10,
      enableCaching: false,
      outputFormat: 'blob',
      parallelProcessing: false
    }
  ): Promise<AnnotatedPage[]> {
    // Parse all rich text queries
    const allSearchQueries: SearchQuery[] = [];
    
    for (const richTextQuery of richTextQueries) {
      const parsedText = RichTextParser.parseAuto(richTextQuery);
      const queries = RichTextParser.toSearchQueries(parsedText);
      allSearchQueries.push(...queries);
    }
    
    // Remove duplicate queries
    const uniqueQueries = this.deduplicateSearchQueries(allSearchQueries);
    
    return await this.annotatePages(uniqueQueries, pageObjects, options);
  }

  /**
   * Parse rich text and return search queries without processing
   */
  parseRichTextQueries(richTextQueries: string[]): {
    plainTextQueries: string[];
    searchQueries: SearchQuery[];
    formattingInfo: Array<{
      originalQuery: string;
      parsedText: import('./rich-text-parser').ParsedRichText;
      hasFormatting: boolean;
    }>;
  } {
    const plainTextQueries: string[] = [];
    const searchQueries: SearchQuery[] = [];
    const formattingInfo: Array<{
      originalQuery: string;
      parsedText: import('./rich-text-parser').ParsedRichText;
      hasFormatting: boolean;
    }> = [];

    for (const richTextQuery of richTextQueries) {
      const parsedText = RichTextParser.parseAuto(richTextQuery);
      const queries = RichTextParser.toSearchQueries(parsedText);
      
      plainTextQueries.push(parsedText.plainText);
      searchQueries.push(...queries);
      formattingInfo.push({
        originalQuery: richTextQuery,
        parsedText,
        hasFormatting: parsedText.hasFormatting
      });
    }

    return {
      plainTextQueries,
      searchQueries: this.deduplicateSearchQueries(searchQueries),
      formattingInfo
    };
  }

  /**
   * Convert plain search queries to rich text with formatting
   */
  static createHTMLQuery(
    text: string,
    formatting: {
      bold?: boolean;
      italic?: boolean;
      underline?: boolean;
      strikethrough?: boolean;
      color?: string;
      backgroundColor?: string;
      fontSize?: number;
    } = {}
  ): string {
    let html = text;
    
    // Apply text decorations
    if (formatting.bold) {
      html = `<strong>${html}</strong>`;
    }
    if (formatting.italic) {
      html = `<em>${html}</em>`;
    }
    if (formatting.underline) {
      html = `<u>${html}</u>`;
    }
    if (formatting.strikethrough) {
      html = `<s>${html}</s>`;
    }
    
    // Apply styles
    const styles: string[] = [];
    if (formatting.color) {
      styles.push(`color: ${formatting.color}`);
    }
    if (formatting.backgroundColor) {
      styles.push(`background-color: ${formatting.backgroundColor}`);
    }
    if (formatting.fontSize) {
      styles.push(`font-size: ${formatting.fontSize}px`);
    }
    
    if (styles.length > 0) {
      html = `<span style="${styles.join('; ')}">${html}</span>`;
    }
    
    return html;
  }

  // Private helper methods

  private deduplicateSearchQueries(queries: SearchQuery[]): SearchQuery[] {
    const seen = new Set<string>();
    const unique: SearchQuery[] = [];
    
    for (const query of queries) {
      const key = `${query.text}:${query.annotationType}:${JSON.stringify(query.formatting || {})}`;
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(query);
      }
    }
    
    return unique;
  }

  // Worker management methods

  /**
   * Get worker pool statistics
   */
  getWorkerStats(): {
    enabled: boolean;
    stats?: {
      totalWorkers: number;
      busyWorkers: number;
      queuedTasks: number;
      activeTasks: number;
      completedTasks: number;
      averageTaskTime: number;
      workerUtilization: number;
    };
  } {
    if (!this.workerManager) {
      return { enabled: false };
    }

    return {
      enabled: true,
      stats: this.workerManager.getStats()
    };
  }

  /**
   * Scale the worker pool
   */
  async scaleWorkers(newSize: number): Promise<void> {
    if (!this.workerManager) {
      throw new Error('Worker manager not initialized');
    }

    await this.workerManager.scaleWorkers(newSize);
  }

  /**
   * Terminate worker pool
   */
  async terminateWorkers(): Promise<void> {
    if (this.workerManager) {
      await this.workerManager.terminate();
      this.workerManager = undefined;
    }
  }

  /**
   * Process pages with optimized load balancing
   */
  async processWithOptimalLoad(
    searchQueries: SearchQuery[],
    pageObjects: PageObject[],
    options: ProcessingOptions = {
      tolerance: 0.8,
      maxResults: 10,
      enableCaching: false,
      outputFormat: 'blob',
      parallelProcessing: true
    }
  ): Promise<{
    results: AnnotatedPage[];
    stats: {
      totalTime: number;
      averageTimePerPage: number;
      parallelEfficiency: number;
      cacheHitRate?: number;
    };
  }> {
    const startTime = performance.now();
    
    // Automatically enable parallel processing if workers are available
    if (this.workerManager && pageObjects.length > 1) {
      options.parallelProcessing = true;
    }

    // Get initial cache stats if available
    const initialCacheStats = options.enableCaching ? this.cacheManager.getStats() : null;

    // Process pages
    const results = await this.annotatePagesWithProgress(
      searchQueries,
      pageObjects,
      options
    );

    const totalTime = performance.now() - startTime;
    const averageTimePerPage = totalTime / pageObjects.length;

    // Calculate parallel efficiency
    let parallelEfficiency = 1.0;
    if (options.parallelProcessing && this.workerManager && pageObjects.length > 1) {
      const workerStats = this.workerManager.getStats();
      const theoreticalSequentialTime = averageTimePerPage * pageObjects.length;
      const actualParallelTime = totalTime;
      parallelEfficiency = theoreticalSequentialTime / actualParallelTime;
    }

    // Calculate cache hit rate if caching is enabled
    let cacheHitRate: number | undefined;
    if (options.enableCaching && initialCacheStats) {
      const finalCacheStats = this.cacheManager.getStats();
      cacheHitRate = finalCacheStats.cacheHitRate;
    }

    return {
      results,
      stats: {
        totalTime,
        averageTimePerPage,
        parallelEfficiency,
        cacheHitRate
      }
    };
  }

  // Batch processing methods

  /**
   * Submit a batch job for processing
   */
  async submitBatchJob(
    searchQueries: SearchQuery[],
    pageObjects: PageObject[],
    options: ProcessingOptions = {
      tolerance: 0.8,
      maxResults: 10,
      enableCaching: false,
      outputFormat: 'blob',
      parallelProcessing: false
    },
    priority: 'low' | 'medium' | 'high' | 'urgent' = 'medium'
  ): Promise<string> {
    return await this.batchProcessor.submitJob(searchQueries, pageObjects, options, priority);
  }

  /**
   * Process a batch job with optimization
   */
  async processBatchJob(
    jobId: string,
    onProgress?: (jobId: string, completed: number, total: number, stats: any) => void
  ): Promise<import('./batch-processor').BatchResult> {
    return await this.batchProcessor.processJob(
      jobId,
      async (searchQueries, pageObjects, options, onProgressInternal) => {
        return await this.annotatePagesWithProgress(
          searchQueries,
          pageObjects,
          options,
          onProgressInternal
        );
      },
      onProgress
    );
  }

  /**
   * Get batch processing queue status
   */
  getBatchQueueStatus(): {
    totalJobs: number;
    activeJobs: number;
    queuedJobs: number;
    estimatedWaitTime: number;
    jobs: Array<{
      id: string;
      priority: string;
      pageCount: number;
      estimatedTime: number;
      waitTime: number;
    }>;
  } {
    return this.batchProcessor.getQueueStatus();
  }

  /**
   * Cancel a batch job
   */
  cancelBatchJob(jobId: string): boolean {
    return this.batchProcessor.cancelJob(jobId);
  }

  /**
   * Get optimization recommendations for batch processing
   */
  getOptimizationRecommendations(): {
    currentStrategy: import('./batch-processor').OptimizationStrategy;
    recommendations: string[];
    performanceMetrics: {
      averageThroughput: number;
      averageEfficiency: number;
      memoryUtilization: number;
    };
  } {
    return this.batchProcessor.getOptimizationRecommendations();
  }

  /**
   * Process pages with intelligent optimization
   */
  async processWithOptimization(
    searchQueries: SearchQuery[],
    pageObjects: PageObject[],
    options: ProcessingOptions = {
      tolerance: 0.8,
      maxResults: 10,
      enableCaching: false,
      outputFormat: 'blob',
      parallelProcessing: false
    }
  ): Promise<{
    results: AnnotatedPage[];
    optimizationStats: {
      batchSize: number;
      workerCount: number;
      cacheStrategy: string;
      totalTime: number;
      throughput: number;
    };
  }> {
    // Submit job for optimization
    const jobId = await this.submitBatchJob(searchQueries, pageObjects, options, 'high');
    
    // Process with optimization
    const batchResult = await this.processBatchJob(jobId);
    
    // Get optimization recommendations for next time
    const recommendations = this.getOptimizationRecommendations();
    
    return {
      results: batchResult.results,
      optimizationStats: {
        batchSize: recommendations.currentStrategy.batchSize,
        workerCount: recommendations.currentStrategy.workerCount,
        cacheStrategy: recommendations.currentStrategy.cacheStrategy,
        totalTime: batchResult.stats.totalTime,
        throughput: batchResult.stats.throughput
      }
    };
  }

  // Citation generation methods

  /**
   * Generate citations for matches
   */
  generateCitations(
    matches: MatchResult[],
    pageObjects: PageObject[],
    citationData: Partial<CitationData>,
    format: 'apa' | 'mla' | 'chicago' | 'harvard' | 'ieee' = 'apa'
  ): CitationResult[] {
    return CitationGenerator.generateMultipleCitations(matches, pageObjects, citationData, format);
  }

  /**
   * Generate citation for a single match
   */
  generateCitation(
    match: MatchResult,
    pageObj: PageObject,
    citationData: Partial<CitationData>,
    format: 'apa' | 'mla' | 'chicago' | 'harvard' | 'ieee' = 'apa'
  ): CitationResult {
    return CitationGenerator.generateCitation(match, pageObj, citationData, format);
  }

  /**
   * Generate bibliography from citations
   */
  generateBibliography(
    citations: CitationResult[],
    groupBy: 'document' | 'format' | 'none' = 'document'
  ): {
    bibliography: string;
    sections?: Array<{
      title: string;
      citations: CitationResult[];
      text: string;
    }>;
  } {
    return CitationGenerator.generateBibliography(citations, groupBy);
  }

  /**
   * Extract citation metadata from URL
   */
  async extractCitationMetadata(url: string, title?: string): Promise<Partial<CitationData>> {
    return await CitationGenerator.extractCitationMetadata(url, title);
  }

  /**
   * Get available citation formats
   */
  getAvailableCitationFormats(): Array<{
    key: string;
    name: string;  
    example: string;
  }> {
    return CitationGenerator.getAvailableFormats();
  }

  /**
   * Export citations in various formats
   */
  exportCitations(
    citations: CitationResult[],
    format: 'json' | 'csv' | 'txt' | 'bibtex' = 'json'
  ): string {
    return CitationGenerator.exportCitations(citations, format);
  }

  /**
   * Annotate pages and generate citations
   */
  async annotatePagesWithCitations(
    searchQueries: SearchQuery[],
    pageObjects: PageObject[],
    citationData: Partial<CitationData>,
    options: ProcessingOptions = {
      tolerance: 0.8,
      maxResults: 10,
      enableCaching: false,
      outputFormat: 'blob',
      parallelProcessing: false
    },
    citationFormat: 'apa' | 'mla' | 'chicago' | 'harvard' | 'ieee' = 'apa'
  ): Promise<{
    pages: AnnotatedPage[];
    citations: CitationResult[];
    bibliography: string;
  }> {
    const pages = await this.annotatePages(searchQueries, pageObjects, options);
    
    const allMatches = pages.flatMap(page => page.matches);
    const citations = this.generateCitations(allMatches, pageObjects, citationData, citationFormat);
    const bibliography = this.generateBibliography(citations).bibliography;
    
    return {
      pages,
      citations,
      bibliography
    };
  }

  /**
   * Cleanup and dispose all resources
   */
  async dispose(): Promise<void> {
    await Promise.all([
      this.terminateWorkers(),
      this.clearCache()
    ]);
  }
}